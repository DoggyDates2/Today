<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>üêï Dog Walking Map</title>
    
    <!-- Leaflet CSS -->
    <link rel="stylesheet" href="https://unpkg.com/leaflet@1.9.4/dist/leaflet.css" />
    
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        body {
            font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, sans-serif;
            background-color: #f8f9fa;
            height: 100vh;
            display: flex;
            flex-direction: column;
        }

        .controls {
            background: white;
            padding: 15px 20px;
            box-shadow: 0 2px 5px rgba(0,0,0,0.1);
            display: flex;
            gap: 20px;
            align-items: center;
            flex-wrap: wrap;
            flex-shrink: 0;
        }

        .control-group {
            display: flex;
            align-items: center;
            gap: 10px;
        }

        .control-group label {
            font-weight: 600;
            color: #333;
        }

        select, input {
            padding: 6px 10px;
            border: 2px solid #e1e5e9;
            border-radius: 6px;
            font-size: 14px;
            transition: border-color 0.2s;
        }

        select:focus, input:focus {
            outline: none;
            border-color: #667eea;
        }

        .main-content {
            display: flex;
            flex: 1;
            overflow: hidden;
        }

        .left-panel {
            width: 300px;
            background: white;
            border-right: 2px solid #e1e5e9;
            display: flex;
            flex-direction: column;
            overflow: hidden;
        }

        .legend-section {
            border-bottom: 2px solid #e1e5e9;
            padding: 10px;
            overflow-y: auto;
            max-height: 500px;
        }

        .legend h3 {
            margin-bottom: 8px;
            color: #333;
            font-size: 15px;
        }

        .legend-item {
            display: flex;
            align-items: center;
            margin-bottom: 4px;
            font-size: 13px;
            cursor: pointer;
            padding: 6px;
            border-radius: 4px;
            transition: all 0.2s;
            border: 1px solid transparent;
        }

        .legend-item:hover {
            background-color: #f8f9fa;
            border-color: #dee2e6;
            transform: translateX(2px);
        }

        .legend-item.active {
            background-color: #e3f2fd;
            border-color: #2196F3;
            font-weight: bold;
        }

        .legend-color {
            width: 14px;
            height: 14px;
            border-radius: 50%;
            margin-right: 8px;
            border: 2px solid #333;
            flex-shrink: 0;
        }

        .edit-section {
            flex: 1;
            padding: 10px;
            overflow-y: auto;
        }

        .edit-section h3 {
            margin-bottom: 15px;
            color: #333;
            font-size: 16px;
        }

        .no-selection {
            text-align: center;
            color: #6c757d;
            font-style: italic;
            margin-top: 20px;
        }

        .btn {
            padding: 8px 12px;
            border: none;
            border-radius: 5px;
            cursor: pointer;
            font-weight: 600;
            transition: all 0.2s;
            font-size: 14px;
            margin: 2px;
        }

        .btn-primary {
            background: #667eea;
            color: white;
        }

        .btn-primary:hover {
            background: #5a6fd8;
        }

        .btn-secondary {
            background: #6c757d;
            color: white;
        }

        .btn-secondary:hover {
            background: #545b62;
        }

        .btn-clear {
            background: #28a745;
            color: white;
        }

        .btn-clear:hover {
            background: #218838;
        }

        .map-container {
            flex: 1;
            position: relative;
            min-height: 400px;
        }

        #map {
            width: 100%;
            height: 100%;
            min-height: 400px;
        }

        .status {
            background: white;
            padding: 8px 20px;
            text-align: center;
            font-weight: 600;
            border-top: 1px solid #e1e5e9;
            font-size: 14px;
            flex-shrink: 0;
        }

        .status.loading {
            background: #fff3cd;
            color: #856404;
        }

        .status.success {
            background: #d4edda;
            color: #155724;
        }

        .status.error {
            background: #f8d7da;
            color: #721c24;
        }

        .dog-info {
            font-size: 12px;
            color: #666;
            margin: 5px 0;
        }
    </style>
</head>
<body>
    <div class="controls">
        <div class="control-group">
            <label for="colorBy">Color by:</label>
            <select id="colorBy">
                <option value="Combined">Combined (Driver:Group)</option>
                <option value="District">District</option>
            </select>
        </div>
        
        <div class="control-group">
            <label for="searchInput">Search:</label>
            <input type="text" id="searchInput" placeholder="Search dogs, combined names, addresses..." />
        </div>

        <div class="control-group">
            <button class="btn btn-secondary" onclick="refreshData()">üîÑ Refresh</button>
            <button class="btn btn-secondary" onclick="showStats()">üìä Stats</button>
        </div>
    </div>

    <div class="main-content">
        <div class="left-panel">
            <div class="legend-section">
                <div style="text-align: center; margin-bottom: 10px;">
                    <button class="btn btn-clear" onclick="clearFilter()" style="width: 100%;">Show All</button>
                </div>
                
                <div id="legendContent">Loading...</div>
            </div>
            
            <div class="edit-section">
                <div id="detailsContent" class="no-selection">
                    Click a marker on the map to see details
                </div>
            </div>
        </div>

        <div class="map-container">
            <div id="map"></div>
        </div>
    </div>

    <div class="status" id="status">Loading dog walking data...</div>

    <!-- Leaflet JS -->
    <script src="https://unpkg.com/leaflet@1.9.4/dist/leaflet.js"></script>
    
    <script>
        // Configuration
        const CONFIG = {
            SHEET_ID: '1mg8d5CLxSR54KhNUL8SpL5jzrGN-bghTsC9vxSK8lR0',
            WORKSHEET_NAME: 'Map',
            API_KEY: 'AIzaSyAGLteYp1k98SZo0FMClRgBX0LBsgpMxqI',
            APPS_SCRIPT_URL: '', // Configure for Google Sheets sync
            DEFAULT_LAT: 42.2968,
            DEFAULT_LNG: -71.2636,
            DEFAULT_ZOOM: 11
        };

        // Extended driver colors with more options
        const DRIVER_COLORS = {
            'Nate': '#1f77b4', 'Aidan': '#ff7f0e', 'Sarah': '#2ca02c', 'Victor': '#d62728',
            'Emily': '#9467bd', 'Mike': '#8c564b', 'Lisa': '#e377c2', 'David': '#7f7f7f',
            'Anna': '#bcbd22', 'Chris': '#17becf', 'Jess': '#ff9896', 'Tom': '#98df8a',
            'Sam': '#c5b0d5', 'Alex': '#c49c94', 'Jordan': '#f7b6d3', 'Taylor': '#c7c7c7',
            'Ali': '#FFD700'
        };

        // Generate a large palette of maximally distinct colors
        function generateMaximallyDistinctColors(count = 100) {
            const colors = [];
            
            // First, add our predefined colors
            Object.values(DRIVER_COLORS).forEach(color => colors.push(color));
            
            // Generate highly distinct colors using systematic HSL distribution
            const hueSteps = Math.ceil(Math.sqrt(count)); // Distribute hues evenly
            const satLightSteps = Math.ceil(count / hueSteps); // Distribute sat/light combinations
            
            for (let h = 0; h < hueSteps; h++) {
                for (let sl = 0; sl < satLightSteps; sl++) {
                    if (colors.length >= count) break;
                    
                    const hue = (h * 360 / hueSteps) % 360;
                    
                    // Create multiple distinct variations for each hue
                    const variations = [
                        [90, 40], // Deep saturated
                        [75, 55], // Medium bright  
                        [85, 35], // Dark rich
                        [70, 65], // Light bright
                        [95, 45], // Vivid
                        [60, 70], // Pastel
                        [80, 30], // Very dark
                        [50, 75], // Very light
                        [100, 50], // Pure saturated
                        [65, 60]  // Balanced
                    ];
                    
                    const [sat, light] = variations[sl % variations.length];
                    const color = hslToHex(hue, sat, light);
                    
                    // Only add if it's sufficiently different from existing colors
                    const isDifferent = colors.every(existingColor => 
                        colorDistance(color, existingColor) > 30 // Minimum perceptual difference
                    );
                    
                    if (isDifferent) {
                        colors.push(color);
                    }
                }
                if (colors.length >= count) break;
            }
            
            return colors;
        }

        // Calculate perceptual color distance (simplified)
        function colorDistance(color1, color2) {
            const rgb1 = hexToRgb(color1);
            const rgb2 = hexToRgb(color2);
            
            // Simple Euclidean distance in RGB space
            const dr = rgb1.r - rgb2.r;
            const dg = rgb1.g - rgb2.g;
            const db = rgb1.b - rgb2.b;
            
            return Math.sqrt(dr*dr + dg*dg + db*db);
        }

        // Convert hex to RGB
        function hexToRgb(hex) {
            const r = parseInt(hex.slice(1, 3), 16);
            const g = parseInt(hex.slice(3, 5), 16);
            const b = parseInt(hex.slice(5, 7), 16);
            return {r, g, b};
        }

        // Generate border colors - darker variants for contrast
        function generateBorderPalette(count = 30) {
            const borderColors = [];
            
            // Dark border colors for contrast
            const baseHues = [];
            for (let i = 0; i < count; i++) {
                baseHues.push((i * 360 / count) % 360);
            }
            
            baseHues.forEach(hue => {
                // Create darker border colors
                const variations = [
                    [90, 25], // Very dark
                    [70, 30], // Dark
                    [80, 20], // Deep dark
                    [60, 35]  // Medium dark
                ];
                
                variations.forEach(([sat, light]) => {
                    const color = hslToHex(hue, sat, light);
                    if (!borderColors.includes(color)) {
                        borderColors.push(color);
                    }
                });
            });
            
            return borderColors;
        }

        // Convert HSL to HEX
        function hslToHex(h, s, l) {
            l /= 100;
            const a = s * Math.min(l, 1 - l) / 100;
            const f = n => {
                const k = (n + h / 30) % 12;
                const color = l - a * Math.max(Math.min(k - 3, 9 - k, 1), -1);
                return Math.round(255 * color).toString(16).padStart(2, '0');
            };
            return `#${f(0)}${f(8)}${f(4)}`;
        }

        // Generate the color palettes
        const COLOR_PALETTE = generateColorPalette(80);
        const BORDER_PALETTE = generateBorderPalette(40);

        // Global variables
        let map, markers = [], allData = [], filteredData = [], colorMap = {}, borderMap = {};
        let selectedMarker = null, selectedRow = null, currentFilter = null;

        function getDriverColor(name) {
            if (!name) return '#666666';
            if (DRIVER_COLORS[name]) return DRIVER_COLORS[name];
            
            // Use hash to get consistent color assignment
            let hash = 0;
            for (let i = 0; i < name.length; i++) {
                hash = name.charCodeAt(i) + ((hash << 5) - hash);
            }
            
            // Skip predefined colors and get from generated palette
            const availableColors = COLOR_PALETTE.slice(Object.keys(DRIVER_COLORS).length);
            return availableColors[Math.abs(hash) % availableColors.length] || '#666666';
        }

        function getDriverBorderColor(name) {
            if (!name) return '#000000';
            
            // Simple hash to determine white or black border
            let hash = 0;
            for (let i = 0; i < name.length; i++) {
                hash = name.charCodeAt(i) + ((hash << 5) - hash);
            }
            
            // Return white or black based on hash
            return (Math.abs(hash) % 2 === 0) ? '#ffffff' : '#000000';
        }

        function getColorForValue(value, attribute) {
            if (attribute === 'Combined') {
                const driverName = value ? value.split(':')[0] : '';
                return getDriverColor(driverName);
            }
            
            // For other attributes, use systematic color assignment too
            if (!value) return '#666666';
            
            // Create a unique assignment system for this attribute
            const attributeKey = `${attribute}_${value}`;
            if (driverColorAssignments[attributeKey]) {
                return driverColorAssignments[attributeKey];
            }
            
            // Find next available color
            const usedColors = Object.values(driverColorAssignments);
            for (let i = 0; i < COLOR_PALETTE.length; i++) {
                const color = COLOR_PALETTE[i];
                if (!usedColors.includes(color)) {
                    driverColorAssignments[attributeKey] = color;
                    return color;
                }
            }
            
            return '#666666';
        }

        function getBorderColorForValue(value, attribute) {
            if (attribute === 'Combined') {
                const driverName = value ? value.split(':')[0] : '';
                return getDriverBorderColor(driverName);
            }
            
            // Simple hash to determine white or black border
            let hash = 0;
            if (value) {
                for (let i = 0; i < value.length; i++) {
                    hash = value.charCodeAt(i) + ((hash << 5) - hash);
                }
            }
            
            // Return white or black based on hash
            return (Math.abs(hash) % 2 === 0) ? '#ffffff' : '#000000';
        }

        function createMarkerIcon(color, borderColor, isSelected = false, markerType = 'circle') {
            const strokeWidth = isSelected ? 4 : 3; // Thicker borders for better visibility
            
            if (markerType === 'field') {
                const size = 29; 
                return L.divIcon({
                    html: `<svg width="${size}" height="${size + 7}" viewBox="0 0 29 36" style="filter: drop-shadow(2px 2px 4px rgba(0,0,0,0.3));">
                        <path d="M14.5 0C6.5 0 0 6.5 0 14.5c0 8.7 14.5 21.5 14.5 21.5s14.5-12.8 14.5-21.5C29 6.5 22.5 0 14.5 0z" 
                              fill="${color}" stroke="${borderColor}" stroke-width="${strokeWidth}"/>
                        <text x="14.5" y="18" text-anchor="middle" fill="${borderColor === '#ffffff' ? '#000000' : '#ffffff'}" font-size="10" font-weight="bold">F</text>
                    </svg>`,
                    className: 'custom-field-marker',
                    iconSize: [size, size + 7],
                    iconAnchor: [size/2, size + 7]
                });
            } else if (markerType === 'parking') {
                const size = 25; 
                return L.divIcon({
                    html: `<div style="width: ${size}px; height: ${size}px; background-color: ${color}; border: ${strokeWidth}px solid ${borderColor}; box-shadow: 0 2px 4px rgba(0,0,0,0.3); display: flex; align-items: center; justify-content: center; color: ${borderColor === '#ffffff' ? '#000000' : '#ffffff'}; font-weight: bold; font-size: 12px;">P</div>`,
                    className: 'custom-parking-marker',
                    iconSize: [size, size],
                    iconAnchor: [size/2, size/2]
                });
            } else if (markerType === 'pin') {
                const size = 22; 
                return L.divIcon({
                    html: `<svg width="${size}" height="${size + 5}" viewBox="0 0 22 27" style="filter: drop-shadow(2px 2px 4px rgba(0,0,0,0.3));">
                        <path d="M11 0C4.9 0 0 4.9 0 11c0 6.6 11 16 11 16s11-9.4 11-16C22 4.9 17.1 0 11 0z" 
                              fill="${color}" stroke="${borderColor}" stroke-width="${strokeWidth}"/>
                    </svg>`,
                    className: 'custom-pin-marker',
                    iconSize: [size, size + 5],
                    iconAnchor: [size/2, size + 5]
                });
            } else {
                const size = 18; 
                return L.divIcon({
                    html: `<div style="width: ${size}px; height: ${size}px; background-color: ${color}; border: ${strokeWidth}px solid ${borderColor}; border-radius: 50%; box-shadow: 0 2px 4px rgba(0,0,0,0.3);"></div>`,
                    className: 'custom-marker',
                    iconSize: [size, size],
                    iconAnchor: [size/2, size/2]
                });
            }
        }

        function initMap() {
            map = L.map('map').setView([CONFIG.DEFAULT_LAT, CONFIG.DEFAULT_LNG], CONFIG.DEFAULT_ZOOM);
            
            // CLEANER MAP - Less busy than OpenStreetMap
            L.tileLayer('https://{s}.basemaps.cartocdn.com/light_all/{z}/{x}/{y}{r}.png', {
                attribution: '¬© OpenStreetMap contributors, ¬© CARTO',
                subdomains: 'abcd',
                maxZoom: 19
            }).addTo(map);

            document.getElementById('colorBy').addEventListener('change', updateMap);
            document.getElementById('searchInput').addEventListener('input', updateMap);
        }

        async function loadData() {
            updateStatus('Loading data...', 'loading');
            
            try {
                const url = `https://sheets.googleapis.com/v4/spreadsheets/${CONFIG.SHEET_ID}/values/${CONFIG.WORKSHEET_NAME}?key=${CONFIG.API_KEY}`;
                const response = await fetch(url);
                
                if (!response.ok) {
                    throw new Error(`HTTP ${response.status}: ${response.statusText}`);
                }
                
                const data = await response.json();
                
                if (!data.values || data.values.length < 2) {
                    throw new Error('No data found in the sheet');
                }
                
                const headers = data.values[0];
                const rows = data.values.slice(1);
                
                allData = rows.map(row => {
                    const obj = {};
                    headers.forEach((header, index) => {
                        obj[header] = row[index] || '';
                    });
                    return obj;
                }).filter(row => {
                    const lat = parseFloat(row['Latitude']);
                    const lng = parseFloat(row['Longitude']);
                    return !isNaN(lat) && !isNaN(lng) && row['Dog Name'] && lat !== 0 && lng !== 0;
                });

                updateStatus(`‚úÖ Loaded ${allData.length} locations`, 'success');
                updateMap();
                
            } catch (error) {
                updateStatus(`Error: ${error.message}`, 'error');
                console.error('Data loading error:', error);
            }
        }

        function updateMap() {
            const colorBy = document.getElementById('colorBy').value;
            const searchTerm = document.getElementById('searchInput').value.toLowerCase();

            filteredData = allData.filter(row => {
                const searchText = `${row['Dog Name']} ${row['Address']} ${row['District']} ${row['Combined']} ${row['Callout']}`.toLowerCase();
                const matchesSearch = searchText.includes(searchTerm);
                
                let matchesFilter = currentFilter === null;
                if (!matchesFilter && currentFilter !== null) {
                    if (colorBy === 'Combined') {
                        const driverName = row['Combined'] ? row['Combined'].split(':')[0] : '';
                        matchesFilter = driverName === currentFilter;
                    } else {
                        matchesFilter = row[colorBy] === currentFilter;
                    }
                }
                
                return matchesSearch && matchesFilter;
            });

            markers.forEach(m => map.removeLayer(m.marker));
            markers = [];

            if (colorBy === 'Combined') {
                const uniqueDrivers = [...new Set(allData.map(row => {
                    const combined = row['Combined'] || '';
                    return combined.split(':')[0];
                }).filter(driver => driver))];
                
                colorMap = {};
                borderMap = {};
                uniqueDrivers.forEach(driver => {
                    colorMap[driver] = getDriverColor(driver);
                    borderMap[driver] = getDriverBorderColor(driver);
                });
            } else {
                const uniqueValues = [...new Set(allData.map(row => row[colorBy]))];
                colorMap = {};
                borderMap = {};
                uniqueValues.forEach(value => {
                    colorMap[value] = getColorForValue(value, colorBy);
                    borderMap[value] = getBorderColorForValue(value, colorBy);
                });
            }

            filteredData.forEach((row, index) => {
                const lat = parseFloat(row['Latitude']);
                const lng = parseFloat(row['Longitude']);
                if (isNaN(lat) || isNaN(lng)) return;

                let color, borderColor;
                if (colorBy === 'Combined') {
                    const driverName = row['Combined'] ? row['Combined'].split(':')[0] : '';
                    color = colorMap[driverName] || '#666666';
                    borderColor = borderMap[driverName] || '#333333';
                } else {
                    color = colorMap[row[colorBy]] || '#666666';
                    borderColor = borderMap[row[colorBy]] || '#333333';
                }
                
                const isSelected = selectedRow === row;
                const dogName = (row['Dog Name'] || '').toLowerCase();
                const hasCallout = row['Callout'] && row['Callout'].trim() !== '';
                
                let markerType = 'circle';
                if (dogName.includes('field')) {
                    markerType = 'field';
                } else if (dogName.includes('parking')) {
                    markerType = 'parking';
                } else if (hasCallout) {
                    markerType = 'pin';
                }
                
                const marker = L.marker([lat, lng], {
                    icon: createMarkerIcon(color, borderColor, isSelected, markerType)
                }).addTo(map);

                // CLEAN POPUP - NO LABELS
                const popupContent = `
                    <strong>üêï ${row['Dog Name']}</strong><br>
                    <strong>üè∑Ô∏è ${row['Combined']}</strong><br>
                    ${row['Address']}<br>
                    ${row['District'] && row['District'].trim() !== '' ? `${row['District']}<br>` : ''}
                    ${row['Capacity'] && row['Capacity'].trim() !== '' ? `${row['Capacity']}<br>` : ''}
                    ${hasCallout ? `<strong>üìù CALLOUT:</strong> <span style="background: yellow; padding: 2px;">${row['Callout']}</span><br>` : ''}
                `;

                marker.bindPopup(popupContent);
                marker.on('click', () => selectMarker(marker, row, index, markerType));

                markers.push({marker, row, index, markerType, color, borderColor});
            });

            updateLegend();
            updateStatus(`Showing ${filteredData.length} of ${allData.length} locations`, 'success');
        }

        function updateLegend() {
            const colorBy = document.getElementById('colorBy').value;
            let html = '';
            
            if (colorBy === 'Combined') {
                Object.entries(colorMap).forEach(([driverName, color]) => {
                    const isActive = currentFilter === driverName;
                    const driverCount = allData.filter(row => {
                        const combined = row['Combined'] || '';
                        return combined.split(':')[0] === driverName;
                    }).length;
                    
                    html += `<div class="legend-item ${isActive ? 'active' : ''}" onclick="filterByCategory('${driverName}')">
                        <div class="legend-color" style="background-color: ${color}"></div>
                        <span>${driverName} (${driverCount} dogs)</span>
                    </div>`;
                });
            } else {
                Object.entries(colorMap).forEach(([category, color]) => {
                    const isActive = currentFilter === category;
                    html += `<div class="legend-item ${isActive ? 'active' : ''}" onclick="filterByCategory('${category}')">
                        <div class="legend-color" style="background-color: ${color}"></div>
                        <span>${category}</span>
                    </div>`;
                });
            }
            
            document.getElementById('legendContent').innerHTML = html;
        }

        function selectMarker(marker, row, index, markerType) {
            if (selectedMarker) {
                const prevData = markers.find(m => m.marker === selectedMarker);
                if (prevData) {
                    selectedMarker.setIcon(createMarkerIcon(prevData.color, prevData.borderColor, false, prevData.markerType));
                }
            }

            selectedMarker = marker;
            selectedRow = row;
            
            const markerData = markers.find(m => m.marker === marker);
            if (markerData) {
                marker.setIcon(createMarkerIcon(markerData.color, markerData.borderColor, true, markerType));
            }

            // CLEAN DETAILS - NO LABELS, SIMPLE LIKE TOOLTIP
            const hasCallout = row['Callout'] && row['Callout'].trim() !== '';
            const detailsHtml = `
                <div style="font-weight: bold; color: #333; margin-bottom: 10px; font-size: 16px;">
                    üêï ${row['Dog Name']}
                </div>
                
                <div style="font-weight: bold; color: #333; margin-bottom: 10px; font-size: 14px;">
                    üè∑Ô∏è ${row['Combined']}
                </div>
                
                <div style="margin-bottom: 8px; color: #666;">
                    ${row['Address']}
                </div>
                
                ${row['District'] && row['District'].trim() !== '' ? `
                <div style="margin-bottom: 8px; color: #666;">
                    ${row['District']}
                </div>` : ''}
                
                ${row['Capacity'] && row['Capacity'].trim() !== '' ? `
                <div style="margin-bottom: 8px; color: #666;">
                    ${row['Capacity']}
                </div>` : ''}
                
                ${hasCallout ? `
                <div style="background: #fff3cd; border: 1px solid #ffeaa7; padding: 8px; border-radius: 4px; margin-bottom: 10px;">
                    <strong>üì¢ CALLOUT:</strong><br>
                    <span style="color: #856404; font-weight: bold;">${row['Callout']}</span>
                </div>` : ''}
                
                <hr style="margin: 15px 0; border: none; border-top: 1px solid #ddd;">
                
                <div style="margin-bottom: 10px;">
                    <label style="font-weight: bold; color: #333; display: block; margin-bottom: 5px;">‚úèÔ∏è Edit:</label>
                    <input type="text" id="editCombined" value="${row['Combined'] || ''}" 
                           style="width: 100%; padding: 8px; border: 1px solid #ddd; border-radius: 4px; font-size: 14px;">
                </div>
                
                <div style="display: flex; gap: 5px;">
                    <button class="btn btn-primary" onclick="saveCombinedName(${index})" style="flex: 1;">üíæ Save</button>
                    <button class="btn btn-secondary" onclick="cancelEdit()" style="flex: 1;">‚ùå Cancel</button>
                </div>
            `;
            
            document.getElementById('detailsContent').innerHTML = detailsHtml;
        }

        function filterByCategory(category) {
            currentFilter = currentFilter === category ? null : category;
            updateMap();
        }

        function clearFilter() {
            currentFilter = null;
            document.getElementById('searchInput').value = '';
            updateMap();
        }

        function showStats() {
            if (allData.length === 0) return;
            
            const drivers = allData.reduce((acc, row) => {
                const combined = row['Combined'] || '';
                const driverName = combined.split(':')[0];
                if (driverName && driverName.trim() !== '') {
                    acc[driverName] = (acc[driverName] || 0) + 1;
                }
                return acc;
            }, {});
            
            const districts = allData.reduce((acc, row) => {
                if (row['District'] && row['District'].trim() !== '') {
                    acc[row['District']] = (acc[row['District']] || 0) + 1;
                }
                return acc;
            }, {});
            
            let statsText = "üìä DETAILED STATISTICS\n\n";
            statsText += "üë§ DRIVERS:\n";
            Object.entries(drivers).sort((a, b) => b[1] - a[1]).forEach(([name, count]) => {
                statsText += `  ${name}: ${count} dogs\n`;
            });
            
            statsText += "\nüó∫Ô∏è DISTRICTS:\n";
            Object.entries(districts).sort((a, b) => b[1] - a[1]).forEach(([district, count]) => {
                statsText += `  ${district}: ${count} dogs\n`;
            });
            
            alert(statsText);
        }

        async function saveCombinedName(index) {
            const newCombined = document.getElementById('editCombined').value;
            if (selectedRow && typeof index === 'number' && allData[index]) {
                selectedRow['Combined'] = newCombined;
                allData[index]['Combined'] = newCombined;
                
                if (CONFIG.APPS_SCRIPT_URL && CONFIG.APPS_SCRIPT_URL.trim() !== '') {
                    try {
                        updateStatus('üíæ Saving to Google Sheets...', 'loading');
                        await fetch(CONFIG.APPS_SCRIPT_URL, {
                            method: 'POST',
                            mode: 'no-cors',
                            headers: { 'Content-Type': 'application/json' },
                            body: JSON.stringify({
                                action: 'updateCombined',
                                rowIndex: index + 2,
                                dogId: selectedRow['Dog ID'],
                                newCombined: newCombined
                            })
                        });
                        updateStatus(`‚úÖ Saved to Google Sheets: ${newCombined}`, 'success');
                    } catch (error) {
                        updateStatus(`‚ö†Ô∏è Saved locally only. Google Sheets error: ${error.message}`, 'error');
                    }
                } else {
                    updateStatus(`‚úÖ Updated locally: ${newCombined}`, 'success');
                }
                
                updateMap();
                
                if (selectedMarker) {
                    const markerData = markers.find(m => m.marker === selectedMarker);
                    if (markerData) {
                        selectMarker(selectedMarker, selectedRow, index, markerData.markerType);
                    }
                }
            }
        }

        function showAppsScriptHelp() {
            const helpText = `üìñ GOOGLE APPS SCRIPT SETUP

To enable saving edits back to your Google Sheet:

1Ô∏è‚É£ Go to script.google.com
2Ô∏è‚É£ Create a new project  
3Ô∏è‚É£ Replace the default code with this:

function doPost(e) {
  try {
    const data = JSON.parse(e.postData.contents);
    const sheet = SpreadsheetApp.openById('${CONFIG.SHEET_ID}').getSheetByName('${CONFIG.WORKSHEET_NAME}');
    
    if (data.action === 'updateCombined') {
      // Update the Combined column (column H)
      sheet.getRange(data.rowIndex, 8).setValue(data.newCombined);
      return ContentService.createTextOutput(JSON.stringify({success: true}));
    }
    
    return ContentService.createTextOutput(JSON.stringify({error: 'Unknown action'}));
  } catch (error) {
    return ContentService.createTextOutput(JSON.stringify({error: error.toString()}));
  }
}

4Ô∏è‚É£ Deploy as Web App
5Ô∏è‚É£ Set permissions to "Anyone"
6Ô∏è‚É£ Copy the Web App URL
7Ô∏è‚É£ Paste it in CONFIG.APPS_SCRIPT_URL in this code

Then your edits will sync back to Google Sheets!`;

            alert(helpText);
        }

        function cancelEdit() {
            if (selectedMarker && selectedRow) {
                const markerData = markers.find(m => m.marker === selectedMarker);
                if (markerData) {
                    const index = allData.findIndex(row => row === selectedRow);
                    selectMarker(selectedMarker, selectedRow, index, markerData.markerType);
                }
            }
        }

        function refreshData() {
            selectedMarker = null;
            selectedRow = null;
            currentFilter = null;
            document.getElementById('detailsContent').innerHTML = '<div class="no-selection">Click a marker on the map to see details</div>';
            loadData();
        }

        function updateStatus(message, type = '') {
            const status = document.getElementById('status');
            status.textContent = message;
            status.className = `status ${type}`;
        }

        document.addEventListener('DOMContentLoaded', function() {
            initMap();
            loadData();
        });
    </script>
</body>
</html>
