<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>üêï Dog Walking Map</title>
    
    <!-- Leaflet CSS -->
    <link rel="stylesheet" href="https://unpkg.com/leaflet@1.9.4/dist/leaflet.css" 
          integrity="sha256-p4NxAoJBhIIN+hmNHrzRCf9tD/miZyoHS5obTRR9BMY=" 
          crossorigin="anonymous" />
    <!-- Leaflet Draw CSS -->
    <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/leaflet.draw/1.0.4/leaflet.draw.css" 
          integrity="sha512-gc3xjCmIy673V6MyOAZhIW93xhM9ei1I+gLbmFjUHIjocENRsLX/QUE1htk5q1XV2D/iie/VQ8DXI6Vu8bexvQ==" 
          crossorigin="anonymous" />
    
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        body {
            font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, sans-serif;
            background-color: #f8f9fa;
            height: 100vh;
            display: flex;
            flex-direction: column;
            overflow: hidden;
            -webkit-font-smoothing: antialiased;
            -moz-osx-font-smoothing: grayscale;
        }

        .controls {
            background: white;
            padding: 15px 20px;
            box-shadow: 0 2px 5px rgba(0,0,0,0.1);
            display: flex;
            gap: 20px;
            align-items: center;
            flex-wrap: wrap;
            flex-shrink: 0;
            min-height: 60px;
            z-index: 1000;
        }

        .control-group {
            display: flex;
            align-items: center;
            gap: 10px;
        }

        .control-group label {
            font-weight: 600;
            color: #333;
            white-space: nowrap;
        }

        select, input[type="text"] {
            padding: 6px 10px;
            border: 2px solid #e1e5e9;
            border-radius: 6px;
            font-size: 14px;
            transition: border-color 0.2s;
            background: white;
        }

        select:focus, input[type="text"]:focus {
            outline: none;
            border-color: #667eea;
            box-shadow: 0 0 0 3px rgba(102, 126, 234, 0.1);
        }

        .group-filters {
            display: flex;
            gap: 10px;
            align-items: center;
        }

        .group-filter-btn {
            padding: 6px 12px;
            border: 2px solid #e1e5e9;
            border-radius: 6px;
            background: white;
            cursor: pointer;
            font-weight: 600;
            transition: all 0.2s;
            font-size: 14px;
            user-select: none;
            -webkit-user-select: none;
            -moz-user-select: none;
            -ms-user-select: none;
        }

        .group-filter-btn:hover:not(:disabled) {
            border-color: #667eea;
            transform: translateY(-1px);
        }

        .group-filter-btn:active:not(:disabled) {
            transform: translateY(0);
        }

        .group-filter-btn.active {
            background: #667eea;
            color: white;
            border-color: #667eea;
        }

        .group-filter-btn:disabled {
            opacity: 0.6;
            cursor: not-allowed;
        }

        .selection-controls {
            display: flex;
            gap: 10px;
            align-items: center;
            border-left: 2px solid #e1e5e9;
            padding-left: 20px;
        }

        .main-content {
            display: flex;
            flex: 1;
            overflow: hidden;
            position: relative;
        }

        .left-panel {
            width: 300px;
            background: white;
            border-right: 2px solid #e1e5e9;
            display: flex;
            flex-direction: column;
            overflow: hidden;
            z-index: 999;
            transition: transform 0.3s ease;
        }

        .panel-toggle {
            display: none;
            position: absolute;
            left: 300px;
            top: 50%;
            transform: translateY(-50%);
            background: white;
            border: 2px solid #e1e5e9;
            border-left: none;
            padding: 10px 5px;
            cursor: pointer;
            z-index: 1000;
            border-radius: 0 5px 5px 0;
        }

        @media (max-width: 768px) {
            .left-panel {
                position: absolute;
                left: 0;
                top: 0;
                bottom: 0;
                transform: translateX(-100%);
                box-shadow: 2px 0 5px rgba(0,0,0,0.1);
            }
            
            .left-panel.open {
                transform: translateX(0);
            }
            
            .panel-toggle {
                display: block;
                left: 0;
            }
            
            .left-panel.open ~ .panel-toggle {
                left: 300px;
            }
        }

        .legend-section {
            border-bottom: 1px solid #e1e5e9;
            padding: 8px;
            overflow-y: auto;
            flex: 1;
            scrollbar-width: thin;
            scrollbar-color: #ccc #f8f9fa;
        }

        .legend-section::-webkit-scrollbar {
            width: 6px;
        }

        .legend-section::-webkit-scrollbar-track {
            background: #f8f9fa;
        }

        .legend-section::-webkit-scrollbar-thumb {
            background: #ccc;
            border-radius: 3px;
        }

        .legend-section::-webkit-scrollbar-thumb:hover {
            background: #999;
        }

        .legend h3 {
            margin-bottom: 8px;
            color: #333;
            font-size: 15px;
        }

        .legend-item {
            display: flex;
            align-items: center;
            margin-bottom: 1px;
            font-size: 12px;
            cursor: pointer;
            padding: 2px 4px;
            border-radius: 3px;
            transition: all 0.2s;
            border: 1px solid transparent;
            user-select: none;
            -webkit-user-select: none;
        }

        .legend-item:hover {
            background-color: #f8f9fa;
            border-color: #dee2e6;
            transform: translateX(2px);
        }

        .legend-item.active {
            background-color: #e3f2fd;
            border-color: #2196F3;
            font-weight: bold;
        }

        .legend-color {
            width: 12px;
            height: 12px;
            border-radius: 50%;
            margin-right: 6px;
            border: 2px solid #333;
            flex-shrink: 0;
        }

        .legend-text {
            flex: 1;
            overflow: hidden;
            text-overflow: ellipsis;
            white-space: nowrap;
        }

        .color-picker {
            width: 16px;
            height: 16px;
            border-radius: 50%;
            border: 1px solid #333;
            margin-left: 6px;
            cursor: pointer;
            flex-shrink: 0;
            padding: 0;
            background: none;
            opacity: 0.7;
            transition: opacity 0.2s;
        }

        .color-picker:hover {
            opacity: 1;
        }

        .color-picker::-webkit-color-swatch-wrapper {
            padding: 0;
            border-radius: 50%;
        }

        .color-picker::-webkit-color-swatch {
            border: none;
            border-radius: 50%;
        }

        .color-picker::-moz-color-swatch {
            border: none;
            border-radius: 50%;
        }

        .edit-section {
            padding: 8px;
            padding-bottom: 20px;
            overflow-y: auto;
            flex-shrink: 0;
            min-height: 180px;
            max-height: 280px;
            scrollbar-width: thin;
            scrollbar-color: #ccc #f8f9fa;
            border-top: 1px solid #e1e5e9;
        }

        .edit-section::-webkit-scrollbar {
            width: 6px;
        }

        .edit-section::-webkit-scrollbar-track {
            background: #f8f9fa;
        }

        .edit-section::-webkit-scrollbar-thumb {
            background: #ccc;
            border-radius: 3px;
        }

        .edit-section h3 {
            margin-bottom: 15px;
            color: #333;
            font-size: 16px;
        }

        .no-selection {
            text-align: center;
            color: #6c757d;
            font-style: italic;
            margin-top: 5px;
            padding: 0 5px;
            font-size: 11px;
        }

        .btn {
            padding: 8px 12px;
            border: none;
            border-radius: 5px;
            cursor: pointer;
            font-weight: 600;
            transition: all 0.2s;
            font-size: 14px;
            margin: 2px;
            user-select: none;
            -webkit-user-select: none;
            display: inline-flex;
            align-items: center;
            gap: 4px;
        }

        .btn:disabled {
            opacity: 0.6;
            cursor: not-allowed;
        }

        .btn:not(:disabled):hover {
            transform: translateY(-1px);
            box-shadow: 0 2px 4px rgba(0,0,0,0.1);
        }

        .btn:not(:disabled):active {
            transform: translateY(0);
            box-shadow: none;
        }

        .btn-primary {
            background: #667eea;
            color: white;
        }

        .btn-primary:hover:not(:disabled) {
            background: #5a6fd8;
        }

        .btn-secondary {
            background: #6c757d;
            color: white;
        }

        .btn-secondary:hover:not(:disabled) {
            background: #545b62;
        }

        .btn-clear {
            background: #28a745;
            color: white;
        }

        .btn-clear:hover:not(:disabled) {
            background: #218838;
        }

        .btn-danger {
            background: #dc3545;
            color: white;
        }

        .btn-danger:hover:not(:disabled) {
            background: #c82333;
        }

        .btn-warning {
            background: #ffc107;
            color: #212529;
        }

        .btn-warning:hover:not(:disabled) {
            background: #e0a800;
        }

        .selection-mode-active {
            background: #fff3cd !important;
            border-color: #ffc107 !important;
            color: #856404 !important;
        }

        .map-container {
            flex: 1;
            position: relative;
            min-height: 400px;
            background: #e5e5e5;
        }

        #map {
            width: 100%;
            height: 100%;
            min-height: 400px;
        }

        .status {
            background: white;
            padding: 8px 20px;
            text-align: center;
            font-weight: 600;
            border-top: 1px solid #e1e5e9;
            font-size: 14px;
            flex-shrink: 0;
            min-height: 36px;
            display: flex;
            align-items: center;
            justify-content: center;
            gap: 8px;
            z-index: 1000;
        }

        .status.loading {
            background: #fff3cd;
            color: #856404;
        }

        .status.success {
            background: #d4edda;
            color: #155724;
        }

        .status.error {
            background: #f8d7da;
            color: #721c24;
        }

        .dog-info {
            font-size: 12px;
            color: #666;
            margin: 5px 0;
        }

        .shape-legend {
            display: flex;
            gap: 15px;
            align-items: center;
            font-size: 12px;
            color: #666;
            margin-left: 10px;
            margin-bottom: 10px;
        }

        .shape-legend-item {
            display: flex;
            align-items: center;
            gap: 5px;
        }

        .bulk-edit-panel {
            background: #f8f9fa;
            border: 2px solid #007bff;
            border-radius: 8px;
            padding: 15px;
            margin-bottom: 10px;
            animation: slideIn 0.3s ease;
        }

        @keyframes slideIn {
            from {
                opacity: 0;
                transform: translateY(-10px);
            }
            to {
                opacity: 1;
                transform: translateY(0);
            }
        }

        .bulk-edit-header {
            display: flex;
            justify-content: space-between;
            align-items: center;
            margin-bottom: 15px;
        }

        .bulk-edit-header h4 {
            color: #007bff;
            margin: 0;
        }

        .selected-count {
            background: #007bff;
            color: white;
            padding: 4px 8px;
            border-radius: 4px;
            font-size: 12px;
            font-weight: bold;
        }

        .bulk-edit-controls {
            display: flex;
            gap: 10px;
            align-items: center;
            flex-wrap: wrap;
        }

        .bulk-edit-input {
            flex: 1;
            min-width: 150px;
            padding: 8px;
            border: 2px solid #ddd;
            border-radius: 4px;
            font-size: 14px;
        }

        .bulk-edit-input:focus {
            outline: none;
            border-color: #007bff;
            box-shadow: 0 0 0 3px rgba(0, 123, 255, 0.1);
        }

        .selected-dogs-preview {
            max-height: 120px;
            overflow-y: auto;
            background: white;
            border: 1px solid #ddd;
            border-radius: 4px;
            padding: 8px;
            margin: 10px 0;
            font-size: 12px;
            scrollbar-width: thin;
            scrollbar-color: #ccc #f8f9fa;
        }

        .selected-dogs-preview::-webkit-scrollbar {
            width: 6px;
        }

        .selected-dogs-preview::-webkit-scrollbar-track {
            background: #f8f9fa;
        }

        .selected-dogs-preview::-webkit-scrollbar-thumb {
            background: #ccc;
            border-radius: 3px;
        }

        .selected-dog-item {
            padding: 2px 0;
            border-bottom: 1px solid #eee;
        }

        .selected-dog-item:last-child {
            border-bottom: none;
        }

        /* Selection highlighting */
        .marker-selected {
            filter: drop-shadow(0 0 10px #007bff) brightness(1.2);
            transform: scale(1.2);
        }

        /* Loading spinner */
        .spinner {
            display: inline-block;
            width: 16px;
            height: 16px;
            border: 2px solid rgba(0,0,0,.1);
            border-radius: 50%;
            border-top-color: #333;
            animation: spin 1s ease-in-out infinite;
        }

        @keyframes spin {
            to { transform: rotate(360deg); }
        }

        @keyframes pulse {
            0% { transform: scale(1); }
            50% { transform: scale(1.1); }
            100% { transform: scale(1); }
        }

        /* Notification styles */
        .notification {
            position: fixed;
            top: 20px;
            right: 20px;
            padding: 12px 20px;
            border-radius: 4px;
            box-shadow: 0 2px 5px rgba(0,0,0,0.2);
            z-index: 9999;
            animation: slideInRight 0.3s ease;
            max-width: 350px;
        }

        @keyframes slideInRight {
            from {
                transform: translateX(100%);
                opacity: 0;
            }
            to {
                transform: translateX(0);
                opacity: 1;
            }
        }

        @keyframes fadeOut {
            from { opacity: 1; }
            to { opacity: 0; }
        }

        .notification-error {
            background: #f8d7da;
            color: #721c24;
            border: 1px solid #f5c6cb;
        }

        .notification-success {
            background: #d4edda;
            color: #155724;
            border: 1px solid #c3e6cb;
        }

        .notification-info {
            background: #cfe2ff;
            color: #084298;
            border: 1px solid #b6d4fe;
        }

        /* Error message styling */
        .error-message {
            background: #f8d7da;
            color: #721c24;
            padding: 10px;
            border-radius: 4px;
            margin: 10px 0;
            font-size: 14px;
            border: 1px solid #f5c6cb;
        }

        /* Success message styling */
        .success-message {
            background: #d4edda;
            color: #155724;
            padding: 10px;
            border-radius: 4px;
            margin: 10px 0;
            font-size: 14px;
            border: 1px solid #c3e6cb;
        }

        /* Accessibility improvements */
        .sr-only {
            position: absolute;
            width: 1px;
            height: 1px;
            padding: 0;
            margin: -1px;
            overflow: hidden;
            clip: rect(0,0,0,0);
            white-space: nowrap;
            border: 0;
        }

        /* Focus visible for keyboard navigation */
        *:focus-visible {
            outline: 2px solid #667eea;
            outline-offset: 2px;
        }

        /* Print styles */
        @media print {
            .controls, .left-panel, .status, .panel-toggle {
                display: none !important;
            }
            
            .map-container {
                width: 100% !important;
            }
        }

        /* Custom popup styles */
        .custom-popup {
            font-size: 13px;
        }
        
        .custom-popup strong {
            color: #333;
        }
        
        .leaflet-popup-content {
            margin: 13px 19px;
            line-height: 1.4;
        }
        
        /* High contrast mode support */
        @media (prefers-contrast: high) {
            .controls, .left-panel, .status {
                border: 2px solid currentColor;
            }
            
            .btn {
                border: 2px solid currentColor;
            }
        }
        
        /* Reduced motion support */
        @media (prefers-reduced-motion: reduce) {
            * {
                animation-duration: 0.01ms !important;
                animation-iteration-count: 1 !important;
                transition-duration: 0.01ms !important;
            }
        }
        
        /* Dark mode support */
        @media (prefers-color-scheme: dark) {
            body {
                background-color: #1a1a1a;
                color: #e0e0e0;
            }
            
            .controls, .left-panel, .status {
                background: #2a2a2a;
                color: #e0e0e0;
            }
            
            input, select {
                background: #3a3a3a;
                color: #e0e0e0;
                border-color: #4a4a4a;
            }
            
            .legend-item:hover {
                background-color: #3a3a3a;
            }
            
            .map-container {
                background: #1a1a1a;
            }
        }

        /* Save indicator styles */
        .save-indicator {
            position: fixed;
            bottom: 20px;
            right: 20px;
            background: white;
            padding: 10px 15px;
            border-radius: 20px;
            box-shadow: 0 2px 10px rgba(0,0,0,0.2);
            display: flex;
            align-items: center;
            gap: 8px;
            z-index: 1000;
            transition: all 0.3s ease;
            font-size: 14px;
        }
        
        .save-indicator.saving {
            background: #fff3cd;
            color: #856404;
        }
        
        .save-indicator.saved {
            background: #d4edda;
            color: #155724;
        }
        
        .save-indicator.error {
            background: #f8d7da;
            color: #721c24;
        }
        
        .save-indicator .spinner {
            width: 14px;
            height: 14px;
            border-width: 2px;
        }
    </style>
</head>
<body>
    <div class="controls">
        <div class="control-group">
            <label for="colorBy">Color by:</label>
            <select id="colorBy" aria-label="Color markers by">
                <option value="Combined">Combined (Driver:Group)</option>
                <option value="District">District</option>
            </select>
        </div>
        
        <div class="control-group">
            <label for="searchInput">Search:</label>
            <input type="text" id="searchInput" placeholder="Search dogs, combined names, addresses..." 
                   aria-label="Search for dogs, drivers, or addresses" autocomplete="off" />
        </div>

        <div class="control-group group-filters">
            <button class="group-filter-btn active" data-group="1" onclick="toggleGroupFilter(1)" 
                    aria-label="Toggle Group 1" aria-pressed="true">Group 1 ‚≠ï</button>
            <button class="group-filter-btn active" data-group="2" onclick="toggleGroupFilter(2)" 
                    aria-label="Toggle Group 2" aria-pressed="true">Group 2 ‚ñ≤</button>
            <button class="group-filter-btn active" data-group="3" onclick="toggleGroupFilter(3)" 
                    aria-label="Toggle Group 3" aria-pressed="true">Group 3 ‚ñ†</button>
        </div>

        <div class="selection-controls">
            <button class="btn btn-warning" id="selectionModeBtn" onclick="toggleSelectionMode()" 
                    aria-label="Toggle selection mode">üéØ Select Mode</button>
            <button class="btn btn-danger" id="clearSelectionBtn" onclick="clearSelection()" 
                    style="display: none;" aria-label="Clear selection">‚úñÔ∏è Clear Selection</button>
        </div>

        <div class="control-group">
            <button class="btn btn-secondary" onclick="refreshData()" aria-label="Refresh data">
                <span id="refreshIcon">üîÑ</span> Refresh
            </button>
            <button class="btn btn-secondary" onclick="showStats()" aria-label="Show statistics">üìä Stats</button>
            <button class="btn btn-secondary" onclick="resetColors()" aria-label="Reset custom colors">üé® Reset Colors</button>
        </div>
    </div>

    <div class="main-content">
        <div class="left-panel" id="leftPanel">
            <div class="legend-section">
                <div style="text-align: center; margin-bottom: 6px;">
                    <button class="btn btn-clear" onclick="clearFilter()" style="width: 100%; padding: 6px 8px; font-size: 12px;">Show All</button>
                </div>
                
                <div id="legendContent" aria-live="polite">Loading...</div>
            </div>
            
            <div class="edit-section">
                <div id="bulkEditPanel" style="display: none;" role="region" aria-label="Bulk edit panel"></div>
                <div id="detailsContent" class="no-selection" role="region" aria-label="Dog details">
                    Click a marker to edit
                </div>
            </div>
        </div>
        
        <button class="panel-toggle" id="panelToggle" onclick="togglePanel()" aria-label="Toggle side panel">
            <span id="panelToggleIcon">‚óÄ</span>
        </button>

        <div class="map-container">
            <div id="map" role="application" aria-label="Dog walking locations map"></div>
        </div>
    </div>

    <div class="status" id="status" role="status" aria-live="polite">
        <span id="statusText">Loading dog walking data...</span>
    </div>

    <!-- Leaflet JS -->
    <script src="https://unpkg.com/leaflet@1.9.4/dist/leaflet.js" 
            integrity="sha256-20nQCchB9co0qIjJZRGuk2/Z9VM+kNiyxNV1lvTlZBo=" 
            crossorigin="anonymous"></script>
    <!-- Leaflet Draw JS -->
    <script src="https://cdnjs.cloudflare.com/ajax/libs/leaflet.draw/1.0.4/leaflet.draw.js" 
            integrity="sha512-ozq8xQKq6urvuU6jNgkfqAmT7jKN2XumbrX1JiB3TnF7tI48DPI4Gy1GXKD/V3EExgAs1V+pRO7vwtS1LHg0Gw==" 
            crossorigin="anonymous"></script>
    
    <script>
        'use strict';

        // Configuration
        const CONFIG = Object.freeze({
            SHEET_ID: '1mg8d5CLxSR54KhNUL8SpL5jzrGN-bghTsC9vxSK8lR0',
            WORKSHEET_NAME: 'Map',
            API_KEY: 'AIzaSyAGLteYp1k98SZo0FMClRgBX0LBsgpMxqI',
            APPS_SCRIPT_URL: 'https://script.google.com/macros/s/AKfycbxA7x2irNO_OkRFu5OdM41lNIP6yqD3nK85aV_rkyUYvl3LDDovpcyJiKghIzkr9qYQ4g/exec',
            DEFAULT_LAT: 42.2968,
            DEFAULT_LNG: -71.2636,
            DEFAULT_ZOOM: 11,
            DEBOUNCE_DELAY: 300,
            THROTTLE_DELAY: 100,
            MAX_RETRIES: 3,
            RETRY_DELAY: 1000,
            MAX_MARKERS: 10000,
            BATCH_SIZE: 100,
            MAX_SELECTION: 500,
            CLICK_DELAY: 300,
            DOUBLE_CLICK_PREVENTION: 500
        });

        // Master color palette
        const ALL_COLORS = Object.freeze([
            '#1f77b4', '#ff7f0e', '#2ca02c', '#d62728', '#9467bd', '#8c564b', '#e377c2', '#7f7f7f',
            '#bcbd22', '#17becf', '#ff9896', '#98df8a', '#c5b0d5', '#c49c94', '#f7b6d3', '#c7c7c7',
            '#FFD700', '#FF6B6B', '#4ECDC4', '#45B7D1', '#96CEB4', '#FECA57', '#FF9FF3', '#54A0FF',
            '#5F27CD', '#00D2D3', '#FF9F43', '#10AC84', '#EE5A24', '#0097E6', '#8C7AE6', '#F79F1F',
            '#A3CB38', '#E74C3C', '#3742FA', '#2F3542', '#FF3838', '#2ECC71', '#9B59B6', '#E67E22',
            '#1ABC9C', '#34495E', '#F39C12', '#E91E63', '#00BCD4', '#607D8B', '#795548', '#009688',
            '#FF5722', '#673AB7', '#3F51B5', '#2196F3', '#03DAC6', '#6200EA', '#FF4081', '#FFAB00',
            '#00E676', '#DD2C00', '#651FFF', '#FF6D00', '#FF1744', '#00E5FF', '#BF360C', '#1B5E20',
            '#0D47A1', '#F57F17', '#4A148C', '#006064', '#D50000', '#00C853', '#304FFE', '#FFD600',
            '#AA00FF', '#00B8D4', '#FF6F00', '#388E3C', '#1976D2', '#FBC02D', '#7B1FA2', '#0097A7',
            '#FF3D00', '#689F38', '#1565C0', '#F9A825', '#8E24AA', '#00ACC1', '#7CB342', '#0277BD',
            '#26C6DA', '#E65100', '#8BC34A', '#0288D1', '#FF8F00', '#4DD0E1', '#FF8A65', '#AED581',
            '#039BE5', '#FFA726', '#5E35B1', '#4FC3F7', '#FFAB91', '#C5E1A5', '#29B6F6', '#FFB74D',
            '#512DA8', '#81C784', '#FFCDD2', '#F8BBD9', '#E1BEE7', '#D1C4E9', '#C5CAE9', '#BBDEFB',
            '#B3E5FC', '#B2EBF2', '#B2DFDB', '#C8E6C9', '#DCEDC8', '#F0F4C3', '#FFF9C4', '#FFECB3',
            '#FFE0B2', '#FFCCBC', '#D7CCC8', '#F5F5F5', '#CFD8DC', '#FF8A80', '#FF80AB', '#EA80FC'
        ]);

        // State management
        const state = {
            map: null,
            markers: [],
            markerLookup: new Map(),
            coordinateLookup: new Map(),
            allData: [],
            filteredData: [],
            colorMap: {},
            selectedMarker: null,
            selectedRow: null,
            currentFilter: null,
            driverColorMap: {},
            customColors: {},
            activeGroups: [1, 2, 3],
            selectionMode: false,
            selectedMarkers: new Set(),
            drawControl: null,
            drawnItems: null,
            isUpdating: false,
            operationId: 0,
            lastClickTime: 0,
            refreshInProgress: false,
            loadAttempts: 0,
            lastUpdateTime: 0,
            dirtyData: new Set(),
            // New async save properties
            pendingSaves: new Map(),
            saveQueue: [],
            isSaving: false,
            failedSaves: [],
            lastSaveAttempt: 0,
            saveIndicatorVisible: false
        };

        // Helper function to call Apps Script with proper error handling
        async function callAppsScript(payload) {
            try {
                const response = await fetch(CONFIG.APPS_SCRIPT_URL, {
                    method: 'POST',
                    body: JSON.stringify(payload)
                });
                
                const text = await response.text();
                
                // Try to parse as JSON
                try {
                    const result = JSON.parse(text);
                    if (!result.success) {
                        throw new Error(result.message || 'Apps Script returned error');
                    }
                    return result;
                } catch (parseError) {
                    // If we can't parse the response, check if it contains common error patterns
                    if (text.includes('<!DOCTYPE html>') || text.includes('<html')) {
                        throw new Error('Apps Script returned HTML instead of JSON. Check deployment settings.');
                    }
                    throw new Error(`Invalid response from Apps Script: ${text.substring(0, 200)}`);
                }
                
            } catch (error) {
                console.error('Apps Script call failed:', error);
                throw error;
            }
        }

        // Create save indicator element
        function createSaveIndicator() {
            const indicator = document.createElement('div');
            indicator.id = 'saveIndicator';
            indicator.className = 'save-indicator';
            indicator.style.display = 'none';
            document.body.appendChild(indicator);
            return indicator;
        }

        // Show/update save indicator
        function updateSaveIndicator(status, message) {
            let indicator = document.getElementById('saveIndicator');
            if (!indicator) {
                indicator = createSaveIndicator();
            }
            
            indicator.style.display = 'flex';
            indicator.className = `save-indicator ${status}`;
            
            if (status === 'saving') {
                indicator.innerHTML = '<span class="spinner"></span><span>' + message + '</span>';
            } else {
                indicator.innerHTML = '<span>' + message + '</span>';
            }
            
            if (status === 'saved' || status === 'error') {
                setTimeout(() => {
                    indicator.style.display = 'none';
                }, 3000);
            }
        }

        // Background save processor
        async function processSaveQueue() {
            if (state.isSaving || state.saveQueue.length === 0) return;
            
            state.isSaving = true;
            const batch = state.saveQueue.splice(0, 10); // Process up to 10 saves at a time
            
            try {
                updateSaveIndicator('saving', `Saving ${batch.length} change${batch.length > 1 ? 's' : ''}...`);
                
                // Group saves by type for efficiency
                const updates = [];
                const bulkUpdates = [];
                
                batch.forEach(save => {
                    if (save.type === 'single') {
                        updates.push({
                            rowIndex: save.rowIndex,
                            updatedData: save.updatedData
                        });
                    } else if (save.type === 'bulk') {
                        bulkUpdates.push(...save.updates);
                    }
                });
                
                // Combine all updates into one request
                const allUpdates = [...updates, ...bulkUpdates];
                
                if (allUpdates.length > 0 && CONFIG.APPS_SCRIPT_URL && !CONFIG.APPS_SCRIPT_URL.includes('YOUR_APPS_SCRIPT_URL_HERE')) {
                    const payload = {
                        action: 'bulkUpdate',
                        updates: allUpdates,
                        timestamp: Date.now()
                    };
                    
                    try {
                        const result = await callAppsScript(payload);
                        
                        if (result.success) {
                            // Remove from pending saves
                            batch.forEach(save => {
                                state.pendingSaves.delete(save.id);
                                if (save.type === 'single') {
                                    state.dirtyData.delete(save.rowIndex);
                                } else if (save.type === 'bulk') {
                                    save.updates.forEach(u => state.dirtyData.delete(u.rowIndex));
                                }
                            });
                            
                            updateSaveIndicator('saved', '‚úì Changes saved');
                        } else {
                            throw new Error(result.message || 'Save failed');
                        }
                    } catch (error) {
                        console.error('Background save error:', error);
                        
                        // Add back to failed saves for retry
                        batch.forEach(save => {
                            save.retryCount = (save.retryCount || 0) + 1;
                            if (save.retryCount < 3) {
                                state.failedSaves.push(save);
                            } else {
                                // Max retries reached
                                state.pendingSaves.delete(save.id);
                                console.error('Save permanently failed after 3 retries:', save);
                            }
                        });
                        
                        updateSaveIndicator('error', '‚ö†Ô∏è Save failed - will retry');
                    }
                }
            } finally {
                state.isSaving = false;
                
                // Process more saves if available
                if (state.saveQueue.length > 0) {
                    setTimeout(() => processSaveQueue(), 100);
                } else if (state.failedSaves.length > 0 && Date.now() - state.lastSaveAttempt > 5000) {
                    // Retry failed saves after 5 seconds
                    state.saveQueue.push(...state.failedSaves);
                    state.failedSaves = [];
                    state.lastSaveAttempt = Date.now();
                    setTimeout(() => processSaveQueue(), 5000);
                }
            }
        }

        // Queue a save operation
        function queueSave(saveData) {
            const saveId = `${saveData.type}_${saveData.rowIndex || 'bulk'}_${Date.now()}`;
            saveData.id = saveId;
            
            state.pendingSaves.set(saveId, saveData);
            state.saveQueue.push(saveData);
            
            // Process queue after a short delay to batch operations
            setTimeout(() => processSaveQueue(), 100);
        }

        // Utility: Generate unique operation ID
        function getOperationId() {
            return ++state.operationId;
        }

        // Utility: Debounce with cancellation
        function debounce(func, wait) {
            let timeoutId = null;
            let lastCallTime = 0;
            
            const debounced = function(...args) {
                const now = Date.now();
                const timeSinceLastCall = now - lastCallTime;
                
                const later = () => {
                    timeoutId = null;
                    lastCallTime = Date.now();
                    func.apply(this, args);
                };
                
                if (timeoutId) {
                    clearTimeout(timeoutId);
                }
                
                if (timeSinceLastCall >= wait) {
                    lastCallTime = now;
                    func.apply(this, args);
                } else {
                    timeoutId = setTimeout(later, wait);
                }
            };
            
            debounced.cancel = function() {
                if (timeoutId) {
                    clearTimeout(timeoutId);
                    timeoutId = null;
                }
            };
            
            return debounced;
        }

        // Utility: Throttle function
        function throttle(func, wait) {
            let inThrottle = false;
            return function(...args) {
                if (!inThrottle) {
                    func.apply(this, args);
                    inThrottle = true;
                    setTimeout(() => {
                        inThrottle = false;
                    }, wait);
                }
            };
        }

        // Utility: Retry with exponential backoff
        async function retryOperation(operation, retries = CONFIG.MAX_RETRIES) {
            let lastError;
            for (let i = 0; i < retries; i++) {
                try {
                    return await operation();
                } catch (error) {
                    lastError = error;
                    if (i === retries - 1) throw error;
                    
                    const delay = CONFIG.RETRY_DELAY * Math.pow(2, i);
                    await new Promise(resolve => setTimeout(resolve, delay));
                }
            }
            throw lastError;
        }

        // Enhanced HTML escaping
        const escapeHtml = (() => {
            const escapeMap = {
                '&': '&amp;',
                '<': '&lt;',
                '>': '&gt;',
                '"': '&quot;',
                "'": '&#x27;',
                '/': '&#x2F;',
                '`': '&#x60;',
                '=': '&#x3D;'
            };
            
            const escapeRegex = new RegExp('[' + Object.keys(escapeMap).join('') + ']', 'g');
            
            return function(text) {
                if (text == null) return '';
                return String(text).replace(escapeRegex, char => escapeMap[char]);
            };
        })();

        // Enhanced coordinate validation
        function validateCoordinates(lat, lng) {
            const latNum = Number(lat);
            const lngNum = Number(lng);
            
            if (!Number.isFinite(latNum) || !Number.isFinite(lngNum)) {
                return false;
            }
            
            if (latNum < -90 || latNum > 90 || lngNum < -180 || lngNum > 180) {
                return false;
            }
            
            // Check for null island or suspiciously small values
            if (Math.abs(latNum) < 0.0001 && Math.abs(lngNum) < 0.0001) {
                return false;
            }
            
            return true;
        }

        // Enhanced color validation
        function validateAndNormalizeColor(color) {
            if (!color || typeof color !== 'string') {
                return '#999999';
            }
            
            color = color.trim();
            
            // Hex color validation and normalization
            const hexMatch = color.match(/^#([0-9a-fA-F]{3}|[0-9a-fA-F]{6})$/);
            if (hexMatch) {
                if (hexMatch[1].length === 3) {
                    // Convert 3-char to 6-char
                    const [r, g, b] = hexMatch[1].split('');
                    return `#${r}${r}${g}${g}${b}${b}`.toLowerCase();
                }
                return color.toLowerCase();
            }
            
            // RGB/RGBA validation
            const rgbMatch = color.match(/^rgba?\((\d+),\s*(\d+),\s*(\d+)(?:,\s*[\d.]+)?\)$/);
            if (rgbMatch) {
                const r = Math.min(255, Math.max(0, parseInt(rgbMatch[1])));
                const g = Math.min(255, Math.max(0, parseInt(rgbMatch[2])));
                const b = Math.min(255, Math.max(0, parseInt(rgbMatch[3])));
                return '#' + [r, g, b].map(x => x.toString(16).padStart(2, '0')).join('');
            }
            
            // Named colors
            const namedColors = {
                'red': '#ff0000', 'green': '#008000', 'blue': '#0000ff',
                'black': '#000000', 'white': '#ffffff', 'gray': '#808080',
                'grey': '#808080', 'yellow': '#ffff00', 'orange': '#ffa500',
                'purple': '#800080', 'pink': '#ffc0cb', 'brown': '#a52a2a',
                'cyan': '#00ffff', 'magenta': '#ff00ff', 'lime': '#00ff00'
            };
            
            const lowerColor = color.toLowerCase();
            if (namedColors[lowerColor]) {
                return namedColors[lowerColor];
            }
            
            return '#999999';
        }

        // Get group from combined field with validation
        function getGroupFromCombined(combined) {
            if (!combined || typeof combined !== 'string') return null;
            
            try {
                const colonIndex = combined.lastIndexOf(':');
                if (colonIndex === -1) return null;
                
                const groupPart = combined.substring(colonIndex + 1).trim();
                
                // Handle multi-group combinations like "1&2", "2&3", "123"
                if (groupPart.includes('&')) {
                    // Parse groups separated by &, like "1&2" or "2&3"
                    const groups = groupPart.split('&').map(g => g.trim()).filter(g => g.match(/^[123]$/));
                    if (groups.length > 1) {
                        // Sort the groups to ensure consistent ordering
                        return groups.sort().join('');
                    }
                } else if (groupPart === '123') {
                    // Handle special case "123" (all groups)
                    return '123';
                }
                
                // Handle single groups
                const groupMatch = groupPart.match(/^(\d+)$/);
                if (groupMatch) {
                    const groupNum = parseInt(groupMatch[1], 10);
                    if (groupNum >= 1 && groupNum <= 3) {
                        return groupNum;
                    }
                }
                
                return null;
            } catch (error) {
                console.warn('Error parsing group from combined:', combined, error);
                return null;
            }
        }

        // Assign driver colors with stability
        function assignDriverColors() {
            if (!state.allData || state.allData.length === 0) {
                state.driverColorMap = {};
                return;
            }
            
            try {
                const drivers = new Set();
                
                state.allData.forEach(row => {
                    if (row && row['Combined']) {
                        const colonIndex = row['Combined'].lastIndexOf(':');
                        const driverName = colonIndex > -1 ? 
                            row['Combined'].substring(0, colonIndex).trim() : 
                            row['Combined'].trim();
                        if (driverName) {
                            drivers.add(driverName);
                        }
                    }
                });
                
                const sortedDrivers = Array.from(drivers).sort();
                const newColorMap = {};
                
                sortedDrivers.forEach((driver, index) => {
                    // Preserve existing color assignments
                    if (state.driverColorMap[driver]) {
                        newColorMap[driver] = state.driverColorMap[driver];
                    } else if (index < ALL_COLORS.length) {
                        newColorMap[driver] = ALL_COLORS[index];
                    } else {
                        // Deterministic color generation
                        let hash = 0;
                        for (let i = 0; i < driver.length; i++) {
                            hash = ((hash << 5) - hash) + driver.charCodeAt(i);
                            hash = hash & hash; // Convert to 32-bit integer
                        }
                        const hue = Math.abs(hash) % 360;
                        newColorMap[driver] = `hsl(${hue}, 70%, 50%)`;
                    }
                });
                
                state.driverColorMap = newColorMap;
                console.log('Assigned colors to', sortedDrivers.length, 'drivers');
            } catch (error) {
                console.error('Error assigning driver colors:', error);
                state.driverColorMap = {};
            }
        }

        // Get driver color with custom color support
        function getDriverColor(name) {
            if (!name || name.trim() === '') return '#999999';
            const trimmedName = name.trim();
            if (state.customColors[trimmedName]) return state.customColors[trimmedName];
            return state.driverColorMap[trimmedName] || '#999999';
        }

        // Get color for value
        function getColorForValue(value, attribute) {
            if (!value) return '#999999';
            
            if (attribute === 'Combined') {
                const colonIndex = value.lastIndexOf(':');
                const driverName = colonIndex > -1 ? 
                    value.substring(0, colonIndex).trim() : 
                    value.trim();
                return getDriverColor(driverName);
            }
            
            if (state.customColors[value]) return state.customColors[value];
            
            // Use color from palette based on hash
            let hash = 0;
            for (let i = 0; i < value.length; i++) {
                hash = ((hash << 5) - hash) + value.charCodeAt(i);
                hash = hash & hash;
            }
            
            const index = Math.abs(hash) % ALL_COLORS.length;
            return ALL_COLORS[index];
        }

        // Create marker icon with caching
        const createMarkerIcon = (() => {
            const iconCache = new Map();
            const maxCacheSize = 1000;
            
            return function(color, isSelected = false, markerType = 'circle', group = null, isInSelection = false, dogName = null, hasCallout = false) {
                // Special handling for Park and Field - use diamond shape
                if (dogName && (dogName.toLowerCase() === 'park' || dogName.toLowerCase() === 'field')) {
                    const isPark = dogName.toLowerCase() === 'park';
                    const strokeColor = isInSelection ? '#007bff' : (isPark ? '#666666' : '#000000');
                    const strokeWidth = isSelected ? 3 : (isInSelection ? 3 : 2);
                    const size = isInSelection ? 24 : 20;
                    
                    // Use white for Park, black for Field
                    const fillColor = isPark ? '#FFFFFF' : '#000000';
                    
                    return L.divIcon({
                        html: `<svg width="${size}" height="${size}" viewBox="0 0 ${size} ${size}" style="filter: drop-shadow(2px 2px 4px rgba(0,0,0,0.3)); ${isInSelection ? 'animation: pulse 2s infinite;' : ''}">
                            <path d="M${size/2} 2 L${size-2} ${size/2} L${size/2} ${size-2} L2 ${size/2} Z" 
                                  fill="${fillColor}" stroke="${strokeColor}" stroke-width="${strokeWidth}"/>
                        </svg>`,
                        className: `custom-diamond-marker ${isInSelection ? 'marker-selected' : ''}`,
                        iconSize: [size, size],
                        iconAnchor: [size/2, size/2]
                    });
                }
                
                const cacheKey = `${color}_${isSelected}_${markerType}_${group}_${isInSelection}_${hasCallout}`;
                
                if (iconCache.has(cacheKey)) {
                    return iconCache.get(cacheKey);
                }
                
                color = validateAndNormalizeColor(color);
                
                const strokeColor = hasCallout ? '#ff0000' : (isInSelection ? '#007bff' : '#000000');
                const strokeWidth = isSelected ? 3 : (isInSelection ? 3 : 2);
                const size = isInSelection ? 20 : 16;
                
                let icon;
                
                try {
                    if (group === 2) {
                        // Triangle for Group 2
                        const svgSize = size + 4;
                        icon = L.divIcon({
                            html: `<svg width="${svgSize}" height="${svgSize}" viewBox="0 0 ${svgSize} ${svgSize}" style="filter: drop-shadow(2px 2px 4px rgba(0,0,0,0.3)); ${isInSelection ? 'animation: pulse 2s infinite;' : ''}">
                                <path d="M${svgSize/2} 2 L${svgSize-2} ${svgSize-2} L2 ${svgSize-2} Z" 
                                      fill="${color}" stroke="${strokeColor}" stroke-width="${strokeWidth}"/>
                            </svg>`,
                            className: `custom-triangle-marker ${isInSelection ? 'marker-selected' : ''}`,
                            iconSize: [svgSize, svgSize],
                            iconAnchor: [svgSize/2, svgSize/2]
                        });
                    } else if (group === 3) {
                        // Square for Group 3
                        icon = L.divIcon({
                            html: `<div style="width: ${size}px; height: ${size}px; background-color: ${color}; border: ${strokeWidth}px solid ${strokeColor}; box-shadow: 0 2px 4px rgba(0,0,0,0.3); ${isInSelection ? 'animation: pulse 2s infinite;' : ''}"></div>`,
                            className: `custom-square-marker ${isInSelection ? 'marker-selected' : ''}`,
                            iconSize: [size, size],
                            iconAnchor: [size/2, size/2]
                        });
                    } else if (group === '12') {
                        // Diamond for Group 1&2
                        const svgSize = size + 4;
                        icon = L.divIcon({
                            html: `<svg width="${svgSize}" height="${svgSize}" viewBox="0 0 ${svgSize} ${svgSize}" style="filter: drop-shadow(2px 2px 4px rgba(0,0,0,0.3)); ${isInSelection ? 'animation: pulse 2s infinite;' : ''}">
                                <path d="M${svgSize/2} 2 L${svgSize-2} ${svgSize/2} L${svgSize/2} ${svgSize-2} L2 ${svgSize/2} Z" 
                                      fill="${color}" stroke="${strokeColor}" stroke-width="${strokeWidth}"/>
                            </svg>`,
                            className: `custom-diamond-marker ${isInSelection ? 'marker-selected' : ''}`,
                            iconSize: [svgSize, svgSize],
                            iconAnchor: [svgSize/2, svgSize/2]
                        });
                    } else if (group === '23') {
                        // Cone/Trapezoid for Group 2&3
                        const svgSize = size + 4;
                        icon = L.divIcon({
                            html: `<svg width="${svgSize}" height="${svgSize}" viewBox="0 0 ${svgSize} ${svgSize}" style="filter: drop-shadow(2px 2px 4px rgba(0,0,0,0.3)); ${isInSelection ? 'animation: pulse 2s infinite;' : ''}">
                                <path d="M3 2 L${svgSize-3} 2 L${svgSize-5} ${svgSize-2} L5 ${svgSize-2} Z" 
                                      fill="${color}" stroke="${strokeColor}" stroke-width="${strokeWidth}"/>
                            </svg>`,
                            className: `custom-cone-marker ${isInSelection ? 'marker-selected' : ''}`,
                            iconSize: [svgSize, svgSize],
                            iconAnchor: [svgSize/2, svgSize/2]
                        });
                    } else if (group === '123') {
                        // Hexagon for Group 1&2&3
                        const svgSize = size + 4;
                        const cx = svgSize/2;
                        const cy = svgSize/2;
                        const r = (svgSize-4)/2;
                        icon = L.divIcon({
                            html: `<svg width="${svgSize}" height="${svgSize}" viewBox="0 0 ${svgSize} ${svgSize}" style="filter: drop-shadow(2px 2px 4px rgba(0,0,0,0.3)); ${isInSelection ? 'animation: pulse 2s infinite;' : ''}">
                                <polygon points="${cx+r},${cy} ${cx+r/2},${cy-r*0.866} ${cx-r/2},${cy-r*0.866} ${cx-r},${cy} ${cx-r/2},${cy+r*0.866} ${cx+r/2},${cy+r*0.866}" 
                                         fill="${color}" stroke="${strokeColor}" stroke-width="${strokeWidth}"/>
                            </svg>`,
                            className: `custom-hexagon-marker ${isInSelection ? 'marker-selected' : ''}`,
                            iconSize: [svgSize, svgSize],
                            iconAnchor: [svgSize/2, svgSize/2]
                        });
                    } else {
                        // Circle for Group 1 (default)
                        icon = L.divIcon({
                            html: `<div style="width: ${size}px; height: ${size}px; background-color: ${color}; border: ${strokeWidth}px solid ${strokeColor}; border-radius: 50%; box-shadow: 0 2px 4px rgba(0,0,0,0.3); ${isInSelection ? 'animation: pulse 2s infinite;' : ''}"></div>`,
                            className: `custom-marker ${isInSelection ? 'marker-selected' : ''}`,
                            iconSize: [size, size],
                            iconAnchor: [size/2, size/2]
                        });
                    }
                    
                    // Manage cache size
                    if (iconCache.size >= maxCacheSize) {
                        const firstKey = iconCache.keys().next().value;
                        iconCache.delete(firstKey);
                    }
                    
                    iconCache.set(cacheKey, icon);
                    return icon;
                    
                } catch (error) {
                    console.error('Error creating marker icon:', error);
                    // Return fallback icon
                    return L.divIcon({
                        html: `<div style="width: 16px; height: 16px; background-color: #999999; border: 2px solid #000000; border-radius: 50%;"></div>`,
                        className: 'custom-marker-fallback',
                        iconSize: [16, 16],
                        iconAnchor: [8, 8]
                    });
                }
            };
        })();

        // Toggle group filter with validation
        function toggleGroupFilter(group) {
            const btn = document.querySelector(`[data-group="${group}"]`);
            if (!btn) return;
            
            const index = state.activeGroups.indexOf(group);
            
            if (index > -1) {
                if (state.activeGroups.length > 1) { // Ensure at least one group remains active
                    state.activeGroups.splice(index, 1);
                    btn.classList.remove('active');
                    btn.setAttribute('aria-pressed', 'false');
                } else {
                    showNotification('At least one group must remain active', 'error');
                    return;
                }
            } else {
                state.activeGroups.push(group);
                state.activeGroups.sort();
                btn.classList.add('active');
                btn.setAttribute('aria-pressed', 'true');
            }
            
            updateMap();
        }

        // Toggle panel for mobile
        function togglePanel() {
            const panel = document.getElementById('leftPanel');
            const toggle = document.getElementById('panelToggle');
            const icon = document.getElementById('panelToggleIcon');
            
            if (panel && toggle && icon) {
                panel.classList.toggle('open');
                icon.textContent = panel.classList.contains('open') ? '‚ñ∂' : '‚óÄ';
            }
        }

        // Show notification
        function showNotification(message, type = 'info', duration = 3000) {
            const existingNotification = document.querySelector('.notification');
            if (existingNotification) {
                existingNotification.remove();
            }
            
            const notification = document.createElement('div');
            notification.className = `notification notification-${type}`;
            notification.textContent = message;
            
            document.body.appendChild(notification);
            
            if (duration > 0) {
                setTimeout(() => {
                    notification.style.animation = 'fadeOut 0.3s ease';
                    setTimeout(() => {
                        if (notification.parentNode) {
                            notification.remove();
                        }
                    }, 300);
                }, duration);
            }
        }

        // Toggle selection mode with proper cleanup
        async function toggleSelectionMode() {
            if (state.isUpdating) {
                showNotification('Please wait for the current operation to complete', 'error');
                return;
            }
            
            const currentOpId = getOperationId();
            
            try {
                const btn = document.getElementById('selectionModeBtn');
                const clearBtn = document.getElementById('clearSelectionBtn');
                
                if (!btn || !clearBtn) {
                    console.error('Selection mode buttons not found');
                    return;
                }
                
                // Prevent double clicks
                const now = Date.now();
                if (now - state.lastClickTime < CONFIG.DOUBLE_CLICK_PREVENTION) {
                    return;
                }
                state.lastClickTime = now;
                
                btn.disabled = true;
                
                state.selectionMode = !state.selectionMode;
                
                if (state.selectionMode) {
                    btn.textContent = 'üéØ Exit Select Mode';
                    btn.classList.add('selection-mode-active');
                    clearBtn.style.display = 'inline-block';
                    
                    enableDrawingTools();
                    updateStatus('üéØ Selection mode active - Draw a polygon around markers to select them', 'loading');
                } else {
                    btn.textContent = 'üéØ Select Mode';
                    btn.classList.remove('selection-mode-active');
                    clearBtn.style.display = 'none';
                    
                    await disableDrawingTools();
                    clearSelection();
                }
                
                // Re-enable button after animation
                setTimeout(() => {
                    if (state.operationId <= currentOpId + 1) {
                        btn.disabled = false;
                    }
                }, 300);
                
            } catch (error) {
                console.error('Error in toggleSelectionMode:', error);
                const btn = document.getElementById('selectionModeBtn');
                if (btn) btn.disabled = false;
                showNotification('Error toggling selection mode', 'error');
            }
        }

        // Enable drawing tools with error recovery
        function enableDrawingTools() {
            if (!state.map || !state.selectionMode) return;
            
            if (!L.Control.Draw) {
                console.error('Leaflet.draw library not loaded');
                updateStatus('Drawing tools not available', 'error');
                return;
            }
            
            try {
                if (!state.drawnItems) {
                    state.drawnItems = new L.FeatureGroup();
                    state.map.addLayer(state.drawnItems);
                }

                if (!state.drawControl) {
                    state.drawControl = new L.Control.Draw({
                        position: 'topleft',
                        edit: {
                            featureGroup: state.drawnItems,
                            remove: true,
                            edit: true
                        },
                        draw: {
                            polygon: {
                                allowIntersection: false,
                                drawError: {
                                    color: '#e1e100',
                                    message: '<strong>Error!</strong> Shape intersects itself!'
                                },
                                shapeOptions: {
                                    color: '#007bff',
                                    fillColor: '#007bff',
                                    fillOpacity: 0.2,
                                    weight: 3
                                },
                                showArea: true
                            },
                            rectangle: {
                                shapeOptions: {
                                    color: '#007bff',
                                    fillColor: '#007bff',
                                    fillOpacity: 0.2,
                                    weight: 3
                                }
                            },
                            circle: false,
                            marker: false,
                            circlemarker: false,
                            polyline: false
                        }
                    });
                    
                    state.map.addControl(state.drawControl);
                }

                // Event listeners with proper binding
                state.map.off('draw:created').on('draw:created', onDrawCreated);
                state.map.off('draw:deleted').on('draw:deleted', onDrawDeleted);
                state.map.off('draw:edited').on('draw:edited', onDrawEdited);
                state.map.off('draw:drawstart').on('draw:drawstart', onDrawStart);
                state.map.off('draw:drawstop').on('draw:drawstop', onDrawStop);
                
            } catch (error) {
                console.error('Error enabling drawing tools:', error);
                updateStatus('Error enabling selection tools', 'error');
                
                // Cleanup on error
                cleanupDrawingTools();
            }
        }

        // Disable drawing tools with cleanup
        async function disableDrawingTools() {
            try {
                if (state.map) {
                    state.map.off('draw:created', onDrawCreated);
                    state.map.off('draw:deleted', onDrawDeleted);
                    state.map.off('draw:edited', onDrawEdited);
                    state.map.off('draw:drawstart', onDrawStart);
                    state.map.off('draw:drawstop', onDrawStop);
                }

                if (state.drawControl && state.map && state.map.hasLayer(state.drawControl)) {
                    state.map.removeControl(state.drawControl);
                }
                state.drawControl = null;

                if (state.drawnItems) {
                    state.drawnItems.clearLayers();
                    if (state.map && state.map.hasLayer(state.drawnItems)) {
                        state.map.removeLayer(state.drawnItems);
                    }
                }
                state.drawnItems = null;

            } catch (error) {
                console.error('Error disabling drawing tools:', error);
            }
        }

        // Cleanup drawing tools
        function cleanupDrawingTools() {
            try {
                if (state.drawControl && state.map) {
                    state.map.removeControl(state.drawControl);
                    state.drawControl = null;
                }
                if (state.drawnItems && state.map) {
                    state.map.removeLayer(state.drawnItems);
                    state.drawnItems = null;
                }
            } catch (error) {
                console.warn('Error during drawing tools cleanup:', error);
            }
        }

        // Drawing event handlers
        function onDrawStart() {
            updateStatus('üéØ Drawing selection area...', 'loading');
        }

        function onDrawStop() {
            if (state.selectionMode) {
                updateStatus(`üéØ Selected ${state.selectedMarkers.size} markers`, 'loading');
            }
        }

        function onDrawCreated(e) {
            if (!state.selectionMode || !state.drawnItems) return;
            
            const layer = e.layer;
            if (!layer) return;
            
            try {
                state.drawnItems.addLayer(layer);
                
                // Add to existing selection
                selectMarkersInPolygonAdditive(layer);
                updateSelectedMarkersDisplay();
                updateBulkEditPanel();
                
                // Limit number of drawn shapes
                const shapeCount = state.drawnItems.getLayers().length;
                if (shapeCount > 10) {
                    showNotification('Maximum 10 selection areas allowed', 'error');
                    // Remove oldest shape
                    const layers = state.drawnItems.getLayers();
                    if (layers.length > 0) {
                        state.drawnItems.removeLayer(layers[0]);
                    }
                }
                
            } catch (error) {
                console.error('Error in onDrawCreated:', error);
                if (state.drawnItems && state.drawnItems.hasLayer(layer)) {
                    state.drawnItems.removeLayer(layer);
                }
                showNotification('Error creating selection area', 'error');
            }
        }

        function onDrawDeleted(e) {
            if (!state.selectionMode || !state.drawnItems) return;
            
            try {
                // Recalculate selection from remaining shapes
                state.selectedMarkers.clear();
                
                state.drawnItems.eachLayer(function(layer) {
                    if (layer) {
                        selectMarkersInPolygonAdditive(layer);
                    }
                });
                
                updateSelectedMarkersDisplay();
                updateBulkEditPanel();
            } catch (error) {
                console.error('Error in onDrawDeleted:', error);
                state.selectedMarkers.clear();
                updateSelectedMarkersDisplay();
                updateBulkEditPanel();
            }
        }

        function onDrawEdited(e) {
            if (!state.selectionMode || !state.drawnItems) return;
            
            try {
                // Recalculate selection from all shapes
                state.selectedMarkers.clear();
                
                state.drawnItems.eachLayer(function(layer) {
                    if (layer) {
                        selectMarkersInPolygonAdditive(layer);
                    }
                });
                
                updateSelectedMarkersDisplay();
                updateBulkEditPanel();
            } catch (error) {
                console.error('Error in onDrawEdited:', error);
                state.selectedMarkers.clear();
                updateSelectedMarkersDisplay();
                updateBulkEditPanel();
            }
        }

        // Select markers in polygon (additive)
        function selectMarkersInPolygonAdditive(polygon) {
            if (!state.selectionMode || !state.markers || state.markers.length === 0) return;
            
            const bounds = polygon.getBounds();
            
            state.markers.forEach(markerData => {
                if (!markerData || !markerData.marker || !markerData.row) return;
                
                const latLng = markerData.marker.getLatLng();
                if (!latLng) return;
                
                // Quick bounds check first
                if (!bounds.contains(latLng)) return;
                
                let isInside = false;
                try {
                    if (polygon instanceof L.Polygon || polygon instanceof L.Rectangle) {
                        const latlngs = polygon.getLatLngs();
                        if (latlngs && latlngs.length > 0) {
                            const outerRing = Array.isArray(latlngs[0]) ? latlngs[0] : latlngs;
                            if (outerRing && outerRing.length >= 3) {
                                isInside = isPointInPolygon(latLng, outerRing);
                            }
                        }
                    }
                } catch (error) {
                    console.error('Error checking polygon intersection:', error);
                    return;
                }
                
                if (isInside) {
                    const dogId = getDogId(markerData.row);
                    if (dogId && state.selectedMarkers.size < CONFIG.MAX_SELECTION) {
                        state.selectedMarkers.add(dogId);
                    } else if (state.selectedMarkers.size >= CONFIG.MAX_SELECTION) {
                        showNotification(`Maximum ${CONFIG.MAX_SELECTION} markers can be selected`, 'error');
                        return;
                    }
                }
            });
        }

        // Optimized point in polygon algorithm
        function isPointInPolygon(point, polygon) {
            if (!polygon || polygon.length < 3) return false;
            if (!point || !Number.isFinite(point.lat) || !Number.isFinite(point.lng)) return false;
            
            const x = point.lat, y = point.lng;
            let inside = false;
            
            for (let i = 0, j = polygon.length - 1; i < polygon.length; j = i++) {
                const xi = polygon[i].lat, yi = polygon[i].lng;
                const xj = polygon[j].lat, yj = polygon[j].lng;
                
                if (!Number.isFinite(xi) || !Number.isFinite(yi) || 
                    !Number.isFinite(xj) || !Number.isFinite(yj)) {
                    continue;
                }
                
                const intersect = ((yi > y) !== (yj > y)) &&
                    (x < (xj - xi) * (y - yi) / (yj - yi) + xi);
                
                if (intersect) inside = !inside;
            }
            
            return inside;
        }

        // Get unique dog ID with collision handling
        function getDogId(row) {
            if (!row) return null;
            
            // Use stored unique ID if available
            if (row['_uniqueId']) {
                return row['_uniqueId'];
            }
            
            // Generate ID based on available fields
            let id = null;
            
            if (row['Dog ID'] && typeof row['Dog ID'] === 'string' && row['Dog ID'].trim()) {
                id = row['Dog ID'].trim();
            } else if (row['Dog Name'] && typeof row['Dog Name'] === 'string' && row['Dog Name'].trim()) {
                id = row['Dog Name'].trim();
                // Add row index to make it unique
                const index = state.allData.indexOf(row);
                if (index >= 0) {
                    id = `${id}_${index}`;
                }
            } else {
                // Use row index if available
                const index = state.allData.indexOf(row);
                if (index >= 0) {
                    id = `dog_${index}`;
                } else {
                    id = `unknown_${Date.now()}_${Math.random().toString(36).substring(2, 9)}`;
                }
            }
            
            // Store for future reference
            row['_uniqueId'] = id;
            return id;
        }

        // Update selected markers display
        const updateSelectedMarkersDisplay = throttle(function() {
            if (!state.markers || state.markers.length === 0) return;
            
            const updates = [];
            
            state.markers.forEach(markerData => {
                if (!markerData || !markerData.marker || !markerData.row) return;
                
                try {
                    const dogId = getDogId(markerData.row);
                    const isInSelection = dogId && state.selectedMarkers.has(dogId);
                    const isSelected = state.selectedMarker === markerData.marker;
                    
                    const colorBy = document.getElementById('colorBy');
                    if (!colorBy) return;
                    
                    let color;
                    // Check if Combined contains "Unassigned" (case-insensitive)
                    if (markerData.row['Combined'] && markerData.row['Combined'].toLowerCase().includes('unassigned')) {
                        color = '#000000'; // Black for unassigned
                    } else if (colorBy.value === 'Combined') {
                        const colonIndex = markerData.row['Combined'] ? 
                            markerData.row['Combined'].lastIndexOf(':') : -1;
                        const driverName = colonIndex > -1 ? 
                            markerData.row['Combined'].substring(0, colonIndex).trim() : '';
                        color = state.colorMap[driverName] || '#999999';
                    } else {
                        color = state.colorMap[markerData.row[colorBy.value]] || '#999999';
                    }
                    
                    const newIcon = createMarkerIcon(color, isSelected, 'group', markerData.group, isInSelection, markerData.row ? markerData.row['Dog Name'] : null, markerData.row && markerData.row['Callout'] && markerData.row['Callout'].trim());
                    updates.push({ marker: markerData.marker, icon: newIcon });
                } catch (error) {
                    console.error('Error updating marker display:', error);
                }
            });
            
            // Batch update icons
            requestAnimationFrame(() => {
                updates.forEach(({ marker, icon }) => {
                    try {
                        marker.setIcon(icon);
                    } catch (e) {
                        console.warn('Error setting marker icon:', e);
                    }
                });
            });
            
            if (state.selectionMode) {
                updateStatus(`üéØ Selected ${state.selectedMarkers.size} markers`, 'loading');
            }
        }, CONFIG.THROTTLE_DELAY);

        // Update bulk edit panel with validation
        function updateBulkEditPanel() {
            const panel = document.getElementById('bulkEditPanel');
            if (!panel) return;
            
            if (state.selectedMarkers.size === 0) {
                panel.style.display = 'none';
                return;
            }
            
            if (!state.allData || state.allData.length === 0) {
                panel.style.display = 'none';
                return;
            }
            
            panel.style.display = 'block';
            
            try {
                // Get selected rows efficiently
                const selectedRows = [];
                for (const dogId of state.selectedMarkers) {
                    const row = state.markerLookup.get(dogId)?.row || 
                               state.allData.find(r => getDogId(r) === dogId);
                    if (row) selectedRows.push(row);
                }
                
                const previewHtml = selectedRows.slice(0, 10).map(row => {
                    const dogName = escapeHtml(row['Dog Name'] || 'Unknown');
                    const combined = escapeHtml(row['Combined'] || 'No Driver');
                    return `<div class="selected-dog-item">${dogName} - ${combined}</div>`;
                }).join('');
                
                const moreText = selectedRows.length > 10 ? 
                    `<div class="selected-dog-item">... and ${selectedRows.length - 10} more</div>` : '';
                
                panel.innerHTML = `
                    <div class="bulk-edit-panel">
                        <div class="bulk-edit-header">
                            <h4>üéØ Bulk Edit Selection</h4>
                            <span class="selected-count">${state.selectedMarkers.size} selected</span>
                        </div>
                        <div class="selected-dogs-preview">
                            ${previewHtml}
                            ${moreText}
                        </div>
                        <div class="bulk-edit-controls">
                            <input type="text" id="bulkCombinedInput" class="bulk-edit-input" 
                                   placeholder="New driver name (groups will be preserved)"
                                   autocomplete="off" />
                            <button class="btn btn-primary" onclick="bulkUpdateSelected()" 
                                    id="bulkUpdateBtn">üíæ Update All</button>
                            <button class="btn btn-secondary" onclick="clearSelection()">‚úñÔ∏è Cancel</button>
                        </div>
                    </div>
                `;
                
                // Focus on input for better UX
                setTimeout(() => {
                    const input = document.getElementById('bulkCombinedInput');
                    if (input) input.focus();
                }, 100);
                
            } catch (error) {
                console.error('Error updating bulk edit panel:', error);
                panel.innerHTML = '<div class="error-message">Error loading selection panel</div>';
            }
        }

        // Clear selection with cleanup
        function clearSelection() {
            state.selectedMarkers.clear();
            updateSelectedMarkersDisplay();
            updateBulkEditPanel();
            
            if (state.drawnItems) {
                state.drawnItems.clearLayers();
            }
            
            if (state.selectionMode) {
                updateStatus('üéØ Selection cleared - Draw a polygon around markers to select them', 'loading');
            } else {
                updateStatus(`Showing ${state.filteredData.length} of ${state.allData.length} locations`, 'success');
            }
        }

        // Bulk update selected with async version
        async function bulkUpdateSelected() {
            if (!state.selectionMode) {
                showNotification('Not in selection mode', 'error');
                return;
            }
            
            const bulkInput = document.getElementById('bulkCombinedInput');
            if (!bulkInput) {
                showNotification('Interface not ready. Please try again.', 'error');
                return;
            }
            
            const newDriverName = bulkInput.value.trim();
            if (!newDriverName) {
                showNotification('Please enter a driver name', 'error');
                bulkInput.focus();
                return;
            }
            
            if (state.selectedMarkers.size === 0) {
                showNotification('No markers selected', 'error');
                return;
            }
            
            try {
                // Get valid selected rows
                const validSelectedRows = [];
                const rowIndices = [];
                const updates = [];
                
                for (const dogId of state.selectedMarkers) {
                    const markerData = state.markerLookup.get(dogId);
                    const row = markerData?.row || state.allData.find(r => getDogId(r) === dogId);
                    if (row) {
                        const index = state.allData.indexOf(row);
                        if (index !== -1) {
                            validSelectedRows.push(row);
                            rowIndices.push(index);
                        }
                    }
                }
                
                if (validSelectedRows.length === 0) {
                    showNotification('No valid markers selected', 'error');
                    return;
                }
                
                // Show confirmation
                if (!confirm(`Update ${validSelectedRows.length} dogs with driver name: "${newDriverName}"?`)) {
                    return;
                }
                
                // Update local data IMMEDIATELY
                rowIndices.forEach((actualIndex, i) => {
                    const row = validSelectedRows[i];
                    const oldCombined = row['Combined'] || '';
                    const colonIndex = oldCombined.lastIndexOf(':');
                    const groupPart = colonIndex > -1 ? oldCombined.substring(colonIndex) : '';
                    const newCombined = newDriverName + groupPart;
                    
                    // Update local data
                    row['Combined'] = newCombined;
                    state.dirtyData.add(actualIndex);
                    
                    // Build update for background save
                    updates.push({
                        rowIndex: actualIndex,
                        updatedData: { 'Combined': newCombined },
                        oldData: { 'Combined': oldCombined }
                    });
                });
                
                // Update UI IMMEDIATELY
                assignDriverColors();
                updateMap();
                clearSelection();
                
                // Show success feedback IMMEDIATELY
                showNotification(`Updated ${validSelectedRows.length} dogs! Saving to Google Sheets...`, 'success');
                
                // Queue the bulk save to happen in the background
                queueSave({
                    type: 'bulk',
                    updates: updates
                });
                
            } catch (error) {
                console.error('Bulk update error:', error);
                showNotification(`Error: ${error.message}`, 'error');
            }
        }

        // Initialize map with error handling
        function initMap() {
            try {
                // Check if Leaflet is loaded
                if (typeof L === 'undefined') {
                    throw new Error('Leaflet library not loaded');
                }
                
                state.map = L.map('map', {
                    center: [CONFIG.DEFAULT_LAT, CONFIG.DEFAULT_LNG],
                    zoom: CONFIG.DEFAULT_ZOOM,
                    preferCanvas: true, // Better performance
                    zoomControl: true,
                    attributionControl: true
                });
                
                // Add tile layer with fallback
                const tileLayer = L.tileLayer('https://{s}.basemaps.cartocdn.com/light_all/{z}/{x}/{y}{r}.png', {
                    attribution: '¬© OpenStreetMap contributors, ¬© CARTO',
                    subdomains: 'abcd',
                    maxZoom: 19,
                    errorTileUrl: 'data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAQAAAC1HAwCAAAAC0lEQVR42mNkYAAAAAYAAjCB0C8AAAAASUVORK5CYII='
                });
                
                tileLayer.on('tileerror', function(error) {
                    console.warn('Tile load error:', error);
                });
                
                tileLayer.addTo(state.map);
                
                // Handle map errors
                state.map.on('error', function(e) {
                    console.error('Map error:', e);
                    showNotification('Map error occurred', 'error');
                });

                // Event listeners with debouncing
                const colorByElement = document.getElementById('colorBy');
                const searchInputElement = document.getElementById('searchInput');
                
                if (colorByElement) {
                    colorByElement.addEventListener('change', debouncedUpdateMap);
                }
                
                if (searchInputElement) {
                    searchInputElement.addEventListener('input', debouncedUpdateMap);
                    searchInputElement.addEventListener('search', debouncedUpdateMap); // For clear button
                }
                
                console.log('Map initialized successfully');
                
            } catch (error) {
                console.error('Error initializing map:', error);
                updateStatus('Failed to initialize map', 'error');
                showNotification('Failed to initialize map. Please refresh the page.', 'error', 0);
            }
        }

        // Load data with comprehensive error handling
        async function loadData() {
            if (state.isUpdating || state.refreshInProgress) {
                console.log('Load data skipped - operation in progress');
                return;
            }
            
            const currentOpId = getOperationId();
            state.isUpdating = true;
            state.loadAttempts++;
            
            updateStatus('<span class="spinner"></span> Loading data...', 'loading');
            
            try {
                // Validate configuration
                if (!CONFIG.SHEET_ID || !CONFIG.API_KEY) {
                    throw new Error('Sheet ID or API key not configured');
                }
                
                const url = `https://sheets.googleapis.com/v4/spreadsheets/${CONFIG.SHEET_ID}/values/${CONFIG.WORKSHEET_NAME}?key=${CONFIG.API_KEY}`;
                
                const controller = new AbortController();
                const timeoutId = setTimeout(() => controller.abort(), 30000); // 30 second timeout
                
                const response = await retryOperation(async () => {
                    const res = await fetch(url, {
                        method: 'GET',
                        headers: {
                            'Accept': 'application/json',
                            'Cache-Control': 'no-cache'
                        },
                        signal: controller.signal
                    });
                    
                    clearTimeout(timeoutId);
                    
                    if (!res.ok) {
                        if (res.status === 403) {
                            throw new Error('Access denied - check API key permissions and ensure the sheet is publicly readable');
                        } else if (res.status === 404) {
                            throw new Error('Sheet not found - check Sheet ID and worksheet name');
                        } else if (res.status === 429) {
                            throw new Error('Rate limit exceeded - please wait a moment and try again');
                        } else {
                            throw new Error(`HTTP ${res.status}: ${res.statusText}`);
                        }
                    }
                    
                    return res;
                });
                
                const data = await response.json();
                
                // Validate response structure
                if (!data || typeof data !== 'object') {
                    throw new Error('Invalid response format from Google Sheets');
                }
                
                if (!data.values || !Array.isArray(data.values)) {
                    throw new Error('No data values found in sheet response');
                }
                
                if (data.values.length < 2) {
                    throw new Error('No data rows found in sheet (only headers or empty)');
                }
                
                const headers = data.values[0];
                const rows = data.values.slice(1);
                
                // Validate required columns
                const requiredColumns = ['Dog Name', 'Latitude', 'Longitude'];
                const missingColumns = requiredColumns.filter(col => !headers.includes(col));
                if (missingColumns.length > 0) {
                    throw new Error(`Missing required columns: ${missingColumns.join(', ')}`);
                }
                
                // Check for too much data
                if (rows.length > CONFIG.MAX_MARKERS) {
                    console.warn(`Sheet has ${rows.length} rows, limiting to ${CONFIG.MAX_MARKERS}`);
                    rows.length = CONFIG.MAX_MARKERS;
                }
                
                // Process data with validation
                const processedData = [];
                const invalidRows = [];
                let validRows = 0;
                
                rows.forEach((row, index) => {
                    try {
                        const obj = {};
                        headers.forEach((header, headerIndex) => {
                            obj[header] = row[headerIndex] || '';
                        });
                        
                        // Validate required fields
                        if (!obj['Dog Name'] || obj['Dog Name'].trim() === '') {
                            invalidRows.push(index + 2); // +2 for 1-based row number + header
                            return;
                        }
                        
                        const lat = parseFloat(obj['Latitude']);
                        const lng = parseFloat(obj['Longitude']);
                        
                        if (!validateCoordinates(lat, lng)) {
                            invalidRows.push(index + 2);
                            return;
                        }
                        
                        // Store parsed coordinates for efficiency
                        obj['_lat'] = lat;
                        obj['_lng'] = lng;
                        obj['_rowIndex'] = index;
                        
                        processedData.push(obj);
                        validRows++;
                        
                    } catch (rowError) {
                        console.warn(`Error processing row ${index + 2}:`, rowError);
                        invalidRows.push(index + 2);
                    }
                });
                
                if (validRows === 0) {
                    throw new Error('No valid data rows found after processing');
                }
                
                // Only update if this is still the current operation
                if (state.operationId <= currentOpId + 1) {
                    state.allData = processedData;
                    state.markerLookup.clear();
                    state.coordinateLookup.clear();
                    state.dirtyData.clear();
                    state.lastUpdateTime = Date.now();
                    
                    let statusMessage = `‚úÖ Loaded ${validRows} locations`;
                    if (invalidRows.length > 0) {
                        const showRows = invalidRows.slice(0, 5);
                        const moreText = invalidRows.length > 5 ? ` and ${invalidRows.length - 5} more` : '';
                        statusMessage += ` (Invalid rows: ${showRows.join(', ')}${moreText})`;
                    }
                    updateStatus(statusMessage, 'success');
                    
                    if (invalidRows.length > 0) {
                        showNotification(`${invalidRows.length} rows skipped due to invalid data`, 'error', 5000);
                    }
                    
                    // Initialize and update
                    assignDriverColors();
                    updateMap();
                    
                    // Reset load attempts on success
                    state.loadAttempts = 0;
                }
                
            } catch (error) {
                console.error('Data loading error:', error);
                
                let userMessage = 'Error loading data';
                let notificationDuration = 5000;
                
                if (error.name === 'AbortError') {
                    userMessage = 'Request timed out - check your connection';
                } else if (error.message.includes('API key')) {
                    userMessage = 'API key issue - check configuration and permissions';
                    notificationDuration = 0; // Permanent
                } else if (error.message.includes('Sheet not found')) {
                    userMessage = 'Sheet not found - verify Sheet ID and worksheet name';
                    notificationDuration = 0;
                } else if (error.message.includes('Rate limit')) {
                    userMessage = 'Rate limit exceeded - please wait and try again';
                } else if (error.message.includes('timeout')) {
                    userMessage = 'Request timed out - check your connection';
                } else if (error.message.includes('network') || error.message.includes('fetch')) {
                    userMessage = 'Network error - check internet connection';
                } else {
                    userMessage = error.message;
                }
                
                updateStatus(`‚ùå ${userMessage}`, 'error');
                showNotification(userMessage, 'error', notificationDuration);
                
                // Clear data on error
                if (state.operationId <= currentOpId + 1) {
                    state.allData = [];
                    state.markers = [];
                    state.filteredData = [];
                    state.markerLookup.clear();
                    state.coordinateLookup.clear();
                }
                
                // Suggest retry for temporary errors
                if (state.loadAttempts < 3 && !error.message.includes('API key') && !error.message.includes('Sheet not found')) {
                    setTimeout(() => {
                        showNotification('Click Refresh to retry loading data', 'info', 0);
                    }, 2000);
                }
                
            } finally {
                state.isUpdating = false;
            }
        }

        // Update map with batching and optimization
        const updateMap = async function() {
            const currentOpId = getOperationId();
            
            try {
                const colorByElement = document.getElementById('colorBy');
                const searchInputElement = document.getElementById('searchInput');
                
                if (!colorByElement || !searchInputElement) {
                    console.error('Required DOM elements not found');
                    return;
                }
                
                const colorBy = colorByElement.value;
                const searchTerm = searchInputElement.value.toLowerCase().trim();

                // Handle empty data
                if (!state.allData || state.allData.length === 0) {
                    cleanupMarkers();
                    state.markers = [];
                    state.filteredData = [];
                    state.markerLookup.clear();
                    state.coordinateLookup.clear();
                    updateLegend();
                    if (!state.isUpdating) {
                        updateStatus('No data available', 'error');
                    }
                    return;
                }

                // Filter data efficiently
                state.filteredData = state.allData.filter(row => {
                    if (!row) return false;
                    
                    try {
                        // Search filter
                        if (searchTerm) {
                            const searchFields = [
                                row['Dog Name'],
                                row['Address'],
                                row['District'],
                                row['Combined'],
                                row['Callout'],
                                row['Dog ID']
                            ].filter(Boolean).join(' ').toLowerCase();
                            
                            if (!searchFields.includes(searchTerm)) {
                                return false;
                            }
                        }
                        
                        // Group filter
                        const group = getGroupFromCombined(row['Combined']);
                        if (group !== null) {
                            // Handle multi-group combinations like "12", "23", "123"
                            if (typeof group === 'string' && group.length > 1) {
                                // Check if any of the groups in the combination are active
                                const hasActiveGroup = group.split('').some(g => state.activeGroups.includes(parseInt(g)));
                                if (!hasActiveGroup) {
                                    return false;
                                }
                            } else if (typeof group === 'number') {
                                // Single group
                                if (!state.activeGroups.includes(group)) {
                                    return false;
                                }
                            }
                        }
                        
                        // Category filter
                        if (state.currentFilter !== null) {
                            if (colorBy === 'Combined') {
                                const colonIndex = row['Combined'] ? row['Combined'].lastIndexOf(':') : -1;
                                const driverName = colonIndex > -1 ? 
                                    row['Combined'].substring(0, colonIndex).trim() : '';
                                if (driverName !== state.currentFilter) {
                                    return false;
                                }
                            } else {
                                if (row[colorBy] !== state.currentFilter) {
                                    return false;
                                }
                            }
                        }
                        
                        return true;
                    } catch (error) {
                        console.warn('Error filtering row:', error);
                        return false;
                    }
                });

                // Build color map
                state.colorMap = {};
                try {
                    const uniqueValues = new Set();
                    
                    if (colorBy === 'Combined') {
                        state.allData.forEach(row => {
                            if (row && row['Combined']) {
                                const colonIndex = row['Combined'].lastIndexOf(':');
                                const driver = colonIndex > -1 ? 
                                    row['Combined'].substring(0, colonIndex).trim() : 
                                    row['Combined'].trim();
                                if (driver) uniqueValues.add(driver);
                            }
                        });
                        
                        uniqueValues.forEach(driver => {
                            state.colorMap[driver] = getDriverColor(driver);
                        });
                    } else {
                        state.allData.forEach(row => {
                            if (row && row[colorBy]) {
                                const value = row[colorBy].trim();
                                if (value) uniqueValues.add(value);
                            }
                        });
                        
                        uniqueValues.forEach(value => {
                            state.colorMap[value] = getColorForValue(value, colorBy);
                        });
                    }
                } catch (colorMapError) {
                    console.error('Error building color map:', colorMapError);
                    state.colorMap = { 'default': '#999999' };
                }

                // Only proceed if this is still the current operation
                if (state.operationId !== currentOpId) return;

                // Clean up existing markers
                cleanupMarkers();
                state.markers = [];
                state.coordinateLookup.clear();

                // Create markers in batches for better performance
                const batchSize = CONFIG.BATCH_SIZE;
                const totalBatches = Math.ceil(state.filteredData.length / batchSize);
                
                for (let batch = 0; batch < totalBatches; batch++) {
                    if (state.operationId !== currentOpId) return;
                    
                    const start = batch * batchSize;
                    const end = Math.min(start + batchSize, state.filteredData.length);
                    const batchData = state.filteredData.slice(start, end);
                    
                    // Process batch
                    await new Promise(resolve => {
                        requestAnimationFrame(() => {
                            batchData.forEach((row, index) => {
                                if (!row) return;
                                
                                try {
                                    const lat = row['_lat'] ?? parseFloat(row['Latitude']);
                                    const lng = row['_lng'] ?? parseFloat(row['Longitude']);
                                    
                                    if (!validateCoordinates(lat, lng)) return;
                                    
                                    // Handle overlapping markers
                                    const coordKey = `${lat.toFixed(6)},${lng.toFixed(6)}`;
                                    const existingCount = state.coordinateLookup.get(coordKey) || 0;
                                    state.coordinateLookup.set(coordKey, existingCount + 1);
                                    
                                    // Offset overlapping markers slightly
                                    const offsetLat = existingCount > 0 ? lat + (existingCount * 0.00001) : lat;
                                    const offsetLng = existingCount > 0 ? lng + (existingCount * 0.00001) : lng;

                                    let color = '#999999';
                                    try {
                                        // Check if Combined contains "Unassigned" (case-insensitive)
                                        if (row['Combined'] && row['Combined'].toLowerCase().includes('unassigned')) {
                                            color = '#000000'; // Black for unassigned
                                        } else if (colorBy === 'Combined') {
                                            const colonIndex = row['Combined'] ? row['Combined'].lastIndexOf(':') : -1;
                                            const driverName = colonIndex > -1 ? 
                                                row['Combined'].substring(0, colonIndex).trim() : '';
                                            color = state.colorMap[driverName] || '#999999';
                                        } else {
                                            const value = row[colorBy] || '';
                                            color = state.colorMap[value] || '#999999';
                                        }
                                    } catch (colorError) {
                                        console.warn('Error determining color:', colorError);
                                    }
                                    
                                    const isSelected = state.selectedRow === row;
                                    const group = getGroupFromCombined(row['Combined']);
                                    const originalIndex = state.allData.indexOf(row);
                                    const dogId = getDogId(row);
                                    const isInSelection = dogId && state.selectedMarkers.has(dogId);
                                    
                                    const marker = L.marker([offsetLat, offsetLng], {
                                        icon: createMarkerIcon(color, isSelected, 'group', group, isInSelection, row['Dog Name'], row['Callout'] && row['Callout'].trim()),
                                        riseOnHover: true,
                                        title: row['Dog Name'] || 'Unknown'
                                    });

                                    // Only add to map if operation hasn't changed
                                    if (state.operationId === currentOpId) {
                                        marker.addTo(state.map);
                                    } else {
                                        return;
                                    }

                                    const groupText = group ? `Group ${group}` : 'No Group';
                                    const isDirty = state.dirtyData.has(originalIndex);
                                    
                                    const popupContent = `
                                        <strong>${escapeHtml(row['Combined'] || 'No Driver')}</strong><br>
                                        ${escapeHtml(row['Dog Name'] || 'Unknown')}<br>
                                        ${row['Address'] ? escapeHtml(row['Address']) + '<br>' : ''}
                                        ${row['Capacity'] ? escapeHtml(row['Capacity']) + '<br>' : ''}
                                        ${row['Callout'] ? `<div style="background: #fff3cd; padding: 4px; border-radius: 3px; margin-top: 4px;"><strong>CALLOUT:</strong> ${escapeHtml(row['Callout'])}</div>` : ''}
                                        ${existingCount > 0 ? `<em>‚ö†Ô∏è ${existingCount + 1} dogs at this location</em>` : ''}
                                    `;

                                    marker.bindPopup(popupContent, {
                                        maxWidth: 300,
                                        className: 'custom-popup'
                                    });
                                    
                                    const markerData = {marker, row, index: originalIndex, group};
                                    
                                    // Store in lookup for fast access
                                    if (dogId) {
                                        state.markerLookup.set(dogId, markerData);
                                    }
                                    
                                    // Click handler with double-click prevention
                                    marker.on('click', function(e) {
                                        const now = Date.now();
                                        if (now - state.lastClickTime < CONFIG.CLICK_DELAY) {
                                            return;
                                        }
                                        state.lastClickTime = now;
                                        
                                        try {
                                            if (!state.allData.includes(row)) {
                                                console.warn('Marker clicked but row data is no longer valid');
                                                showNotification('This marker\'s data is outdated. Please refresh.', 'error');
                                                return;
                                            }
                                            
                                            if (state.selectionMode) {
                                                e.originalEvent.stopPropagation();
                                                const dogId = getDogId(row);
                                                if (!dogId) return;
                                                
                                                if (state.selectedMarkers.has(dogId)) {
                                                    state.selectedMarkers.delete(dogId);
                                                } else if (state.selectedMarkers.size < CONFIG.MAX_SELECTION) {
                                                    state.selectedMarkers.add(dogId);
                                                } else {
                                                    showNotification(`Maximum ${CONFIG.MAX_SELECTION} markers can be selected`, 'error');
                                                    return;
                                                }
                                                
                                                updateSelectedMarkersDisplay();
                                                updateBulkEditPanel();
                                            } else {
                                                const validIndex = state.allData.indexOf(row);
                                                if (validIndex === -1) {
                                                    showNotification('Marker data not found. Please refresh.', 'error');
                                                    return;
                                                }
                                                
                                                selectMarker(marker, row, validIndex, group);
                                            }
                                        } catch (clickError) {
                                            console.error('Error handling marker click:', clickError);
                                            showNotification('Error handling marker click', 'error');
                                        }
                                    });

                                    state.markers.push(markerData);
                                    
                                } catch (markerError) {
                                    console.warn('Error creating marker:', markerError);
                                }
                            });
                            
                            resolve();
                        });
                    });
                    
                    // Update status periodically during batch processing
                    if (batch % 5 === 0) {
                        updateStatus(`Loading markers... ${Math.round((end / state.filteredData.length) * 100)}%`, 'loading');
                    }
                }

                // Only update UI if this is still the current operation
                if (state.operationId === currentOpId) {
                    updateLegend();
                    
                    // Update selections
                    if (state.selectionMode && state.selectedMarkers.size > 0) {
                        const visibleDogIds = new Set();
                        state.filteredData.forEach(row => {
                            if (row) {
                                const dogId = getDogId(row);
                                if (dogId) visibleDogIds.add(dogId);
                            }
                        });
                        
                        const toRemove = [];
                        state.selectedMarkers.forEach(dogId => {
                            if (!visibleDogIds.has(dogId)) {
                                toRemove.push(dogId);
                            }
                        });
                        
                        toRemove.forEach(dogId => state.selectedMarkers.delete(dogId));
                        
                        if (state.selectedMarkers.size > 0) {
                            updateStatus(`üéØ Selected ${state.selectedMarkers.size} markers`, 'loading');
                            updateBulkEditPanel();
                        } else {
                            updateStatus('üéØ Selection cleared (markers filtered out)', 'loading');
                            updateBulkEditPanel();
                        }
                    } else if (!state.selectionMode && !state.isUpdating) {
                        updateStatus(`Showing ${state.filteredData.length} of ${state.allData.length} locations`, 'success');
                    }
                }
                
            } catch (error) {
                console.error('Error in updateMap:', error);
                updateStatus('Error updating map display', 'error');
                showNotification('Error updating map display', 'error');
            }
        };

        // Create debounced version
        const debouncedUpdateMap = debounce(updateMap, CONFIG.DEBOUNCE_DELAY);

        // Cleanup markers efficiently
        function cleanupMarkers() {
            if (state.markers && state.markers.length > 0) {
                // Remove in batches for better performance
                const batchSize = 100;
                const batches = Math.ceil(state.markers.length / batchSize);
                
                for (let i = 0; i < batches; i++) {
                    const start = i * batchSize;
                    const end = Math.min(start + batchSize, state.markers.length);
                    const batch = state.markers.slice(start, end);
                    
                    requestAnimationFrame(() => {
                        batch.forEach(m => {
                            if (m && m.marker) {
                                try {
                                    m.marker.off();
                                    if (state.map.hasLayer(m.marker)) {
                                        state.map.removeLayer(m.marker);
                                    }
                                } catch (e) {
                                    console.warn('Error removing marker:', e);
                                }
                            }
                        });
                    });
                }
            }
        }

        // Update legend with improved performance
        const updateLegend = throttle(function() {
            const colorByElement = document.getElementById('colorBy');
            const legendContent = document.getElementById('legendContent');
            
            if (!colorByElement || !legendContent) return;
            
            const colorBy = colorByElement.value;
            
            try {
                // Remove existing event listeners
                const existingPickers = legendContent.querySelectorAll('.color-picker');
                existingPickers.forEach(picker => {
                    if (picker._colorChangeHandler) {
                        picker.removeEventListener('change', picker._colorChangeHandler);
                        picker.removeEventListener('input', picker._colorChangeHandler);
                        delete picker._colorChangeHandler;
                    }
                });
                
                // Build legend HTML
                const sortedEntries = Object.entries(state.colorMap).sort(([a], [b]) => a.localeCompare(b));
                const legendItems = [];
                
                sortedEntries.forEach(([key, color]) => {
                    if (!key || !color) return;
                    
                    try {
                        const isActive = state.currentFilter === key;
                        let displayText = escapeHtml(key);
                        
                        // Add counts for drivers
                        if (colorBy === 'Combined' && state.allData && state.allData.length > 0) {
                            const groupCounts = { 1: 0, 2: 0, 3: 0, total: 0 };
                            
                            state.allData.forEach(row => {
                                if (!row || !row['Combined']) return;
                                
                                const colonIndex = row['Combined'].lastIndexOf(':');
                                const rowDriver = colonIndex > -1 ? 
                                    row['Combined'].substring(0, colonIndex).trim() : 
                                    row['Combined'].trim();
                                    
                                if (rowDriver === key) {
                                    groupCounts.total++;
                                    const group = getGroupFromCombined(row['Combined']);
                                    if (group && groupCounts[group] !== undefined) {
                                        groupCounts[group]++;
                                    }
                                }
                            });
                            
                            if (groupCounts.total > 0) {
                                const counts = [];
                                for (let i = 1; i <= 3; i++) {
                                    if (groupCounts[i] > 0) {
                                        counts.push(groupCounts[i]);
                                    }
                                }
                                displayText += ` (${counts.join(', ')})`;
                            }
                        }
                        
                        const dataKey = escapeHtml(key);
                        const safeKey = key.replace(/'/g, "\\'").replace(/"/g, '\\"').replace(/\\/g, '\\\\');
                        
                        legendItems.push(`
                            <div class="legend-item ${isActive ? 'active' : ''}" 
                                 onclick="filterByCategory('${safeKey}')"
                                 role="button"
                                 tabindex="0"
                                 aria-label="Filter by ${dataKey}"
                                 aria-pressed="${isActive}">
                                <div class="legend-color" style="background-color: ${color}"></div>
                                <span class="legend-text">${displayText}</span>
                                <input type="color" class="color-picker" value="${color}" 
                                       data-category="${dataKey}"
                                       aria-label="Change color for ${dataKey}"
                                       onclick="event.stopPropagation()" />
                            </div>
                        `);
                    } catch (itemError) {
                        console.warn('Error creating legend item:', itemError);
                    }
                });
                
                legendContent.innerHTML = legendItems.join('');
                
                // Add event listeners for color pickers
                const newPickers = legendContent.querySelectorAll('.color-picker');
                newPickers.forEach(picker => {
                    const handler = function(e) {
                        e.stopPropagation();
                        const categoryName = this.getAttribute('data-category');
                        if (categoryName) {
                            changeCustomColor(categoryName, this.value);
                        }
                    };
                    picker._colorChangeHandler = handler;
                    picker.addEventListener('change', handler);
                    picker.addEventListener('click', e => e.stopPropagation());
                });
                
                // Add keyboard support for legend items
                const legendItemElements = legendContent.querySelectorAll('.legend-item');
                legendItemElements.forEach(item => {
                    item.addEventListener('keydown', function(e) {
                        if (e.key === 'Enter' || e.key === ' ') {
                            e.preventDefault();
                            this.click();
                        }
                    });
                });
                
            } catch (error) {
                console.error('Error updating legend:', error);
                legendContent.innerHTML = '<div class="error-message">Error loading legend</div>';
            }
        }, CONFIG.THROTTLE_DELAY);

        // Change custom color
        function changeCustomColor(categoryName, newColor) {
            console.log('Changing color for:', categoryName, 'to:', newColor);
            const normalizedColor = validateAndNormalizeColor(newColor);
            state.customColors[categoryName] = normalizedColor;
            assignDriverColors();
            updateMap();
            showNotification(`Color updated for ${categoryName}`, 'success', 2000);
        }

        // Reset colors
        function resetColors() {
            if (Object.keys(state.customColors).length === 0) {
                showNotification('No custom colors to reset', 'info');
                return;
            }
            
            console.log('Resetting all custom colors');
            state.customColors = {};
            assignDriverColors();
            updateMap();
            showNotification('All custom colors reset', 'success');
        }

        // Select marker with validation
        function selectMarker(marker, row, index, group) {
            if (!marker || !row || !state.map) {
                console.error('Invalid parameters for selectMarker');
                return;
            }
            
            try {
                // Clear previous selection
                if (state.selectedMarker && state.selectedMarker !== marker) {
                    const prevData = state.markers.find(m => m && m.marker === state.selectedMarker);
                    if (prevData) {
                        try {
                            const colorByElement = document.getElementById('colorBy');
                            if (colorByElement) {
                                let color = '#999999';
                                if (colorByElement.value === 'Combined') {
                                    const colonIndex = prevData.row['Combined'] ? 
                                        prevData.row['Combined'].lastIndexOf(':') : -1;
                                    const driverName = colonIndex > -1 ? 
                                        prevData.row['Combined'].substring(0, colonIndex).trim() : '';
                                    color = state.colorMap[driverName] || '#999999';
                                } else {
                                    color = state.colorMap[prevData.row[colorByElement.value]] || '#999999';
                                }
                                
                                const dogId = getDogId(prevData.row);
                                const isInSelection = dogId && state.selectedMarkers.has(dogId);
                                state.selectedMarker.setIcon(createMarkerIcon(color, false, 'group', prevData.group, isInSelection, prevData.row ? prevData.row['Dog Name'] : null, prevData.row && prevData.row['Callout'] && prevData.row['Callout'].trim()));
                            }
                        } catch (clearError) {
                            console.warn('Error clearing previous marker:', clearError);
                        }
                    }
                }

                state.selectedMarker = marker;
                state.selectedRow = row;
                
                // Update marker appearance
                try {
                    const colorByElement = document.getElementById('colorBy');
                    if (colorByElement) {
                        let color = '#999999';
                        if (colorByElement.value === 'Combined') {
                            const colonIndex = row['Combined'] ? row['Combined'].lastIndexOf(':') : -1;
                            const driverName = colonIndex > -1 ? 
                                row['Combined'].substring(0, colonIndex).trim() : '';
                            color = state.colorMap[driverName] || '#999999';
                        } else {
                            color = state.colorMap[row[colorByElement.value]] || '#999999';
                        }
                        
                        const dogId = getDogId(row);
                        const isInSelection = dogId && state.selectedMarkers.has(dogId);
                        marker.setIcon(createMarkerIcon(color, true, 'group', group, isInSelection, row ? row['Dog Name'] : null, row && row['Callout'] && row['Callout'].trim()));
                    }
                } catch (iconError) {
                    console.warn('Error updating marker icon:', iconError);
                }

                // Update details panel - SIMPLIFIED VERSION
                try {
                    const actualIndex = state.allData.indexOf(row);
                    const combinedName = row['Combined'] || 'No Driver';
                    const dogName = row['Dog Name'] || 'Unknown';
                    
                    const detailsHtml = `
                        <div style="font-weight: bold; color: #333; margin-bottom: 6px; font-size: 13px; text-align: center; padding: 4px 6px; background: #f8f9fa; border-radius: 3px;">
                            ${escapeHtml(combinedName)} - ${escapeHtml(dogName)}
                        </div>
                        
                        <div style="margin-bottom: 4px;">
                            <input type="text" id="editCombined" value="${escapeHtml(row['Combined'] ? row['Combined'].split(':')[0] : '')}" 
                                   placeholder="Driver name"
                                   style="width: 100%; padding: 4px 6px; border: 1px solid #ddd; border-radius: 3px; font-size: 12px;"
                                   autocomplete="off">
                        </div>
                        
                        <div style="display: flex; gap: 3px;">
                            <button class="btn btn-primary" onclick="saveCombinedName(${actualIndex})" 
                                    id="saveBtn" style="flex: 1; padding: 4px 6px; font-size: 11px;">
                                üíæ Save
                            </button>
                            <button class="btn btn-secondary" onclick="cancelEdit()" 
                                    style="flex: 1; padding: 4px 6px; font-size: 11px;">
                                ‚úñÔ∏è Cancel
                            </button>
                        </div>
                    `;
                    
                    const detailsContent = document.getElementById('detailsContent');
                    if (detailsContent) {
                        detailsContent.innerHTML = detailsHtml;
                        
                        // Focus on input for quick editing
                        setTimeout(() => {
                            const input = document.getElementById('editCombined');
                            if (input) {
                                input.focus();
                                input.select();
                                
                                // Add enter key support
                                input.addEventListener('keydown', function(e) {
                                    if (e.key === 'Enter') {
                                        e.preventDefault();
                                        saveCombinedName(actualIndex);
                                    } else if (e.key === 'Escape') {
                                        e.preventDefault();
                                        cancelEdit();
                                    }
                                });
                            }
                        }, 100);
                    }
                } catch (panelError) {
                    console.error('Error updating details panel:', panelError);
                    showNotification('Error showing dog details', 'error');
                }
                
            } catch (error) {
                console.error('Error in selectMarker:', error);
                showNotification('Error selecting marker', 'error');
            }
        }

        // Filter by category
        function filterByCategory(category) {
            state.currentFilter = state.currentFilter === category ? null : category;
            updateMap();
            
            if (state.currentFilter) {
                showNotification(`Filtering by: ${category}`, 'info', 2000);
            } else {
                showNotification('Filter cleared', 'info', 2000);
            }
        }

        // Clear filter
        function clearFilter() {
            state.currentFilter = null;
            const searchInput = document.getElementById('searchInput');
            if (searchInput) searchInput.value = '';
            updateMap();
            showNotification('All filters cleared', 'info', 2000);
        }

        // Show statistics with enhanced formatting
        function showStats() {
            if (!state.allData || state.allData.length === 0) {
                showNotification('No data available for statistics', 'error');
                return;
            }
            
            try {
                const stats = {
                    drivers: {},
                    districts: {},
                    groups: { 1: 0, 2: 0, 3: 0, 'None': 0 },
                    callouts: 0,
                    totalDogs: state.allData.length,
                    avgDogsPerDriver: 0
                };
                
                state.allData.forEach(row => {
                    // Count drivers
                    if (row['Combined']) {
                        const colonIndex = row['Combined'].lastIndexOf(':');
                        const driverName = colonIndex > -1 ? 
                            row['Combined'].substring(0, colonIndex).trim() : 
                            row['Combined'].trim();
                        if (driverName) {
                            stats.drivers[driverName] = (stats.drivers[driverName] || 0) + 1;
                        }
                    }
                    
                    // Count districts
                    if (row['District'] && row['District'].trim()) {
                        stats.districts[row['District']] = (stats.districts[row['District']] || 0) + 1;
                    }
                    
                    // Count groups
                    const group = getGroupFromCombined(row['Combined']);
                    if (group) {
                        if (typeof group === 'string' && group.length > 1) {
                            // Multi-group combination like "12", "23", "123"
                            if (!stats.groups[group]) stats.groups[group] = 0;
                            stats.groups[group]++;
                        } else if (typeof group === 'number' && stats.groups[group] !== undefined) {
                            // Single group
                            stats.groups[group]++;
                        } else {
                            stats.groups['None']++;
                        }
                    } else {
                        stats.groups['None']++;
                    }
                    
                    // Count callouts
                    if (row['Callout'] && row['Callout'].trim()) {
                        stats.callouts++;
                    }
                });
                
                const driverCount = Object.keys(stats.drivers).length;
                stats.avgDogsPerDriver = driverCount > 0 ? 
                    Math.round(stats.totalDogs / driverCount * 10) / 10 : 0;
                
                let statsText = "üìä DOG WALKING STATISTICS\n";
                statsText += "‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ\n\n";
                
                statsText += `üìà SUMMARY:\n`;
                statsText += `  Total Dogs: ${stats.totalDogs}\n`;
                statsText += `  Total Drivers: ${driverCount}\n`;
                statsText += `  Avg Dogs/Driver: ${stats.avgDogsPerDriver}\n`;
                statsText += `  Dogs with Callouts: ${stats.callouts}\n\n`;
                
                statsText += "üî¢ GROUPS:\n";
                Object.entries(stats.groups).forEach(([group, count]) => {
                    if (count > 0) {
                        const percent = Math.round(count / stats.totalDogs * 100);
                        const bar = '‚ñà'.repeat(Math.round(percent / 5));
                        statsText += `  Group ${group}: ${count} dogs (${percent}%) ${bar}\n`;
                    }
                });
                
                statsText += "\nüë§ TOP 10 DRIVERS:\n";
                Object.entries(stats.drivers)
                    .sort((a, b) => b[1] - a[1])
                    .slice(0, 10)
                    .forEach(([name, count], index) => {
                        statsText += `  ${index + 1}. ${name}: ${count} dogs\n`;
                    });
                
                if (Object.keys(stats.districts).length > 0) {
                    statsText += "\nüó∫Ô∏è TOP DISTRICTS:\n";
                    Object.entries(stats.districts)
                        .sort((a, b) => b[1] - a[1])
                        .slice(0, 5)
                        .forEach(([district, count]) => {
                            const percent = Math.round(count / stats.totalDogs * 100);
                            statsText += `  ${district}: ${count} dogs (${percent}%)\n`;
                        });
                }
                
                alert(statsText);
            } catch (error) {
                console.error('Error showing stats:', error);
                showNotification('Error generating statistics', 'error');
            }
        }

        // Save combined name with async version
        async function saveCombinedName(index) {
            const editInput = document.getElementById('editCombined');
            const saveBtn = document.getElementById('saveBtn');
            
            if (!editInput) {
                showNotification('Error: Edit input field not found', 'error');
                return;
            }
            
            const newDriverName = editInput.value.trim();
            
            if (!state.selectedRow || typeof index !== 'number' || !state.allData || !state.allData[index]) {
                showNotification('Error: Invalid selection', 'error');
                return;
            }

            const actualIndex = state.allData.indexOf(state.selectedRow);
            if (actualIndex === -1) {
                showNotification('Error: Could not find row in data', 'error');
                return;
            }

            try {
                // Get the current combined value to extract the group number
                const oldCombined = state.selectedRow['Combined'] || '';
                const colonIndex = oldCombined.lastIndexOf(':');
                
                // Extract the group number (or default to empty)
                let groupPart = '';
                if (colonIndex > -1) {
                    groupPart = oldCombined.substring(colonIndex); // Includes the colon
                }
                
                // Create the new combined value
                const newCombined = newDriverName ? newDriverName + groupPart : groupPart.substring(1);
                
                // Update local data IMMEDIATELY
                state.selectedRow['Combined'] = newCombined;
                state.allData[actualIndex]['Combined'] = newCombined;
                state.dirtyData.add(actualIndex);
                
                // Update UI IMMEDIATELY
                assignDriverColors();
                updateMap();
                
                // Show success feedback IMMEDIATELY
                showNotification('Updated! Saving to Google Sheets...', 'success', 2000);
                
                // Refresh the selected marker display IMMEDIATELY
                if (state.selectedMarker) {
                    const markerData = state.markers.find(m => m && m.marker === state.selectedMarker);
                    if (markerData) {
                        const newGroup = getGroupFromCombined(newCombined);
                        selectMarker(state.selectedMarker, state.selectedRow, actualIndex, newGroup);
                    }
                }
                
                // Queue the save to happen in the background
                queueSave({
                    type: 'single',
                    rowIndex: actualIndex,
                    updatedData: { 'Combined': newCombined },
                    oldData: { 'Combined': oldCombined } // Store old data for potential revert
                });
                
            } catch (error) {
                console.error('Error in saveCombinedName:', error);
                showNotification(`Error: ${error.message}`, 'error');
            }
        }

        // Cancel edit
        function cancelEdit() {
            if (state.selectedMarker && state.selectedRow) {
                const markerData = state.markers.find(m => m && m.marker === state.selectedMarker);
                if (markerData) {
                    const index = state.allData.indexOf(state.selectedRow);
                    selectMarker(state.selectedMarker, state.selectedRow, index, markerData.group);
                }
            }
        }

        // Refresh data with state preservation
        async function refreshData() {
            if (state.refreshInProgress) {
                showNotification('Refresh already in progress', 'info');
                return;
            }
            
            // Check for unsaved changes
            if (state.dirtyData.size > 0 || state.pendingSaves.size > 0) {
                if (!confirm(`You have ${state.dirtyData.size + state.pendingSaves.size} unsaved changes. Refreshing will lose these changes. Continue?`)) {
                    return;
                }
            }
            
            try {
                state.refreshInProgress = true;
                
                // Animate refresh button
                const refreshIcon = document.getElementById('refreshIcon');
                if (refreshIcon) {
                    refreshIcon.style.animation = 'spin 1s linear infinite';
                }
                
                // Reset operation state
                state.isUpdating = false;
                state.operationId = getOperationId();
                
                // Exit selection mode if active
                if (state.selectionMode) {
                    state.selectionMode = false;
                    const btn = document.getElementById('selectionModeBtn');
                    const clearBtn = document.getElementById('clearSelectionBtn');
                    if (btn) {
                        btn.textContent = 'üéØ Select Mode';
                        btn.classList.remove('selection-mode-active');
                        btn.disabled = false;
                    }
                    if (clearBtn) {
                        clearBtn.style.display = 'none';
                    }
                    await disableDrawingTools();
                }
                
                // Clear selections but preserve filters
                state.selectedMarker = null;
                state.selectedRow = null;
                state.selectedMarkers.clear();
                state.dirtyData.clear();
                state.pendingSaves.clear();
                state.saveQueue = [];
                state.failedSaves = [];
                
                // Reset UI
                const detailsContent = document.getElementById('detailsContent');
                if (detailsContent) {
                    detailsContent.innerHTML = '<div class="no-selection">Click a marker to edit</div>';
                }
                
                const bulkEditPanel = document.getElementById('bulkEditPanel');
                if (bulkEditPanel) {
                    bulkEditPanel.style.display = 'none';
                }
                
                // Reload data
                await loadData();
                
                showNotification('Data refreshed successfully', 'success');
                
            } catch (error) {
                console.error('Error refreshing data:', error);
                showNotification('Error refreshing data', 'error');
            } finally {
                state.refreshInProgress = false;
                
                // Stop animation
                const refreshIcon = document.getElementById('refreshIcon');
                if (refreshIcon) {
                    refreshIcon.style.animation = '';
                }
            }
        }

        // Update status with HTML support
        function updateStatus(message, type = '') {
            const status = document.getElementById('status');
            const statusText = document.getElementById('statusText');
            
            if (status && statusText) {
                statusText.innerHTML = message;
                status.className = `status ${type}`;
            }
        }

        // Add periodic check for pending saves
        setInterval(() => {
            if (state.pendingSaves.size > 0 && !state.isSaving) {
                const pendingCount = state.pendingSaves.size;
                console.log(`${pendingCount} saves pending...`);
                
                // Show indicator if many saves are pending
                if (pendingCount > 5) {
                    updateSaveIndicator('saving', `${pendingCount} saves pending...`);
                }
            }
        }, 5000);

        // Initialize application
        function initializeApp() {
            try {
                console.log('DOM loaded, initializing application...');
                
                // Check browser compatibility
                const requiredFeatures = [
                    'Promise' in window,
                    'fetch' in window,
                    'Map' in window,
                    'Set' in window,
                    'requestAnimationFrame' in window
                ];
                
                const missingFeatures = requiredFeatures.filter((feature, index) => {
                    const featureName = ['Promise', 'fetch', 'Map', 'Set', 'requestAnimationFrame'][index];
                    if (!eval(feature)) {
                        console.error(`Missing required feature: ${featureName}`);
                        return true;
                    }
                    return false;
                });
                
                if (missingFeatures.length > 0) {
                    updateStatus('Your browser is missing required features. Please use a modern browser.', 'error');
                    showNotification('Browser compatibility issue detected', 'error', 0);
                    return;
                }
                
                // Validate required DOM elements
                const requiredElements = [
                    'map', 'colorBy', 'searchInput', 'status', 'statusText',
                    'legendContent', 'detailsContent', 'bulkEditPanel',
                    'selectionModeBtn', 'clearSelectionBtn', 'leftPanel',
                    'panelToggle', 'refreshIcon'
                ];
                
                const missingElements = requiredElements.filter(id => !document.getElementById(id));
                
                if (missingElements.length > 0) {
                    console.error('Missing required DOM elements:', missingElements);
                    updateStatus('Application initialization failed - missing interface elements', 'error');
                    showNotification('Critical error: Missing interface elements', 'error', 0);
                    return;
                }
                
                // Create save indicator
                createSaveIndicator();
                
                // Add keyboard shortcuts
                document.addEventListener('keydown', function(e) {
                    // Escape key
                    if (e.key === 'Escape') {
                        if (state.selectionMode) {
                            toggleSelectionMode();
                        } else if (state.selectedMarker) {
                            state.selectedMarker = null;
                            state.selectedRow = null;
                            updateMap();
                            const detailsContent = document.getElementById('detailsContent');
                            if (detailsContent) {
                                detailsContent.innerHTML = '<div class="no-selection">Click a marker to edit</div>';
                            }
                        }
                    }
                    
                    // Ctrl/Cmd + F for search focus
                    if ((e.ctrlKey || e.metaKey) && e.key === 'f') {
                        e.preventDefault();
                        const searchInput = document.getElementById('searchInput');
                        if (searchInput) {
                            searchInput.focus();
                            searchInput.select();
                        }
                    }
                    
                    // Ctrl/Cmd + R for refresh
                    if ((e.ctrlKey || e.metaKey) && e.key === 'r') {
                        e.preventDefault();
                        refreshData();
                    }
                });
                
                // Initialize map
                initMap();
                
                // Load initial data
                loadData();
                
                // Set up periodic auto-save reminder
                setInterval(() => {
                    if (state.dirtyData.size > 0 || state.pendingSaves.size > 0) {
                        const totalUnsaved = state.dirtyData.size + state.pendingSaves.size;
                        showNotification(`${totalUnsaved} unsaved changes`, 'info', 3000);
                    }
                }, 60000); // Every minute
                
                console.log('Application initialized successfully');
                
            } catch (error) {
                console.error('Error during application initialization:', error);
                updateStatus('Application initialization failed', 'error');
                showNotification('Failed to initialize application', 'error', 0);
            }
        }

        // Global error handler
        window.addEventListener('error', function(event) {
            console.error('Global error:', event.error);
            console.error('Stack:', event.error?.stack);
            
            // Don't show notification for network errors during normal operation
            if (event.error?.message?.includes('fetch')) {
                return;
            }
            
            showNotification('An unexpected error occurred', 'error');
        });

        // Unhandled promise rejection handler
        window.addEventListener('unhandledrejection', function(event) {
            console.error('Unhandled promise rejection:', event.reason);
            
            // Don't show notification for cancelled operations
            if (event.reason?.message?.includes('aborted')) {
                return;
            }
            
            showNotification('An unexpected error occurred', 'error');
            event.preventDefault();
        });

        // Page visibility handler to pause updates when hidden
        document.addEventListener('visibilitychange', function() {
            if (document.hidden) {
                console.log('Page hidden, pausing updates');
                // Cancel any pending operations
                if (debouncedUpdateMap.cancel) {
                    debouncedUpdateMap.cancel();
                }
            } else {
                console.log('Page visible, resuming updates');
                // Check if data is stale
                if (Date.now() - state.lastUpdateTime > 300000) { // 5 minutes
                    showNotification('Page was inactive. Consider refreshing data.', 'info', 5000);
                }
            }
        });

        // Handle page unload - updated to check for pending saves
        window.addEventListener('beforeunload', function(e) {
            if (state.pendingSaves.size > 0 || state.dirtyData.size > 0) {
                e.preventDefault();
                e.returnValue = 'You have unsaved changes. Are you sure you want to leave?';
                return e.returnValue;
            }
        });

        // Memory cleanup on unload
        window.addEventListener('unload', function() {
            // Clean up map resources
            if (state.map) {
                state.map.remove();
            }
            
            // Clear all data structures
            state.markers = [];
            state.markerLookup.clear();
            state.coordinateLookup.clear();
            state.selectedMarkers.clear();
            state.dirtyData.clear();
            state.pendingSaves.clear();
        });

        // Expose limited API for debugging
        window.dogWalkingMapDebug = {
            getState: () => ({ ...state }),
            getConfig: () => ({ ...CONFIG }),
            clearCache: () => {
                if (createMarkerIcon.iconCache) {
                    createMarkerIcon.iconCache.clear();
                }
                console.log('Cache cleared');
            },
            getMarkerCount: () => state.markers.length,
            getSelectedCount: () => state.selectedMarkers.size,
            getDirtyCount: () => state.dirtyData.size,
            getPendingSavesCount: () => state.pendingSaves.size,
            getSaveQueueLength: () => state.saveQueue.length,
            testAppsScript: async () => {
                try {
                    console.log('Testing Apps Script connection...');
                    const testPayload = {
                        action: 'getAllData'
                    };
                    
                    const response = await fetch(CONFIG.APPS_SCRIPT_URL, {
                        method: 'POST',
                        headers: {
                            'Content-Type': 'application/json',
                        },
                        body: JSON.stringify(testPayload)
                    });
                    
                    const text = await response.text();
                    console.log('Response status:', response.status);
                    console.log('Response headers:', response.headers);
                    console.log('Response text:', text);
                    
                    try {
                        const json = JSON.parse(text);
                        console.log('Parsed response:', json);
                        
                        if (json.success) {
                            console.log('‚úÖ Apps Script connection successful!');
                            console.log('Row count:', json.data?.rowCount);
                        } else {
                            console.error('‚ùå Apps Script returned error:', json.message);
                        }
                    } catch (e) {
                        console.error('Failed to parse response as JSON:', e);
                        if (text.includes('<!DOCTYPE html>') || text.includes('<html')) {
                            console.error('Apps Script is returning HTML. Check deployment settings.');
                        }
                    }
                } catch (error) {
                    console.error('Apps Script test failed:', error);
                }
            },
            testSaveOperation: async () => {
                try {
                    console.log('Testing save operation...');
                    const testPayload = {
                        action: 'updateRow',
                        rowIndex: 0,
                        updatedData: { 'Combined': 'Test Driver:1' },
                        timestamp: Date.now()
                    };
                    
                    const result = await callAppsScript(testPayload);
                    console.log('Save test result:', result);
                } catch (error) {
                    console.error('Save test failed:', error);
                }
            }
        };

        // Initialize when DOM is ready
        document.addEventListener('DOMContentLoaded', initializeApp);

        console.log('Dog Walking Map application loaded. Version: 3.1.3 (Multi-group shapes & larger edit area)');
        console.log('Use dogWalkingMapDebug.testAppsScript() to test the connection');
    </script>
</body>
</html>
