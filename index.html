<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>üêï Dog Walking Map</title>
    
    <!-- Leaflet CSS -->
    <link rel="stylesheet" href="https://unpkg.com/leaflet@1.9.4/dist/leaflet.css" />
    
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        body {
            font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, sans-serif;
            background-color: #f8f9fa;
            height: 100vh;
            display: flex;
            flex-direction: column;
        }

        .controls {
            background: white;
            padding: 15px 20px;
            box-shadow: 0 2px 5px rgba(0,0,0,0.1);
            display: flex;
            gap: 20px;
            align-items: center;
            flex-wrap: wrap;
            flex-shrink: 0;
        }

        .control-group {
            display: flex;
            align-items: center;
            gap: 10px;
        }

        .control-group label {
            font-weight: 600;
            color: #333;
        }

        select, input {
            padding: 6px 10px;
            border: 2px solid #e1e5e9;
            border-radius: 6px;
            font-size: 14px;
            transition: border-color 0.2s;
        }

        select:focus, input:focus {
            outline: none;
            border-color: #667eea;
        }

        .main-content {
            display: flex;
            flex: 1;
            overflow: hidden;
        }

        .left-panel {
            width: 300px;
            background: white;
            border-right: 2px solid #e1e5e9;
            display: flex;
            flex-direction: column;
            overflow: hidden;
        }

        .legend-section {
            border-bottom: 1px solid #e1e5e9;
            padding: 8px;
            overflow-y: auto;
            max-height: 600px;
        }

        .legend h3 {
            margin-bottom: 8px;
            color: #333;
            font-size: 15px;
        }

        .legend-item {
            display: flex;
            align-items: center;
            margin-bottom: 1px;
            font-size: 12px;
            cursor: pointer;
            padding: 2px 4px;
            border-radius: 3px;
            transition: all 0.2s;
            border: 1px solid transparent;
        }

        .legend-item:hover {
            background-color: #f8f9fa;
            border-color: #dee2e6;
            transform: translateX(2px);
        }

        .legend-item.active {
            background-color: #e3f2fd;
            border-color: #2196F3;
            font-weight: bold;
        }

        .legend-color {
            width: 12px;
            height: 12px;
            border-radius: 50%;
            margin-right: 6px;
            border: 2px solid #333;
            flex-shrink: 0;
        }

        .legend-text {
            flex: 1;
        }

        .color-picker {
            width: 16px;
            height: 16px;
            border-radius: 50%;
            border: 1px solid #333;
            margin-left: 6px;
            cursor: pointer;
            flex-shrink: 0;
            padding: 0;
            background: none;
        }

        .color-picker::-webkit-color-swatch-wrapper {
            padding: 0;
            border-radius: 50%;
        }

        .color-picker::-webkit-color-swatch {
            border: none;
            border-radius: 50%;
        }

        .edit-section {
            flex: 0.7;
            padding: 8px;
            overflow-y: auto;
        }

        .edit-section h3 {
            margin-bottom: 15px;
            color: #333;
            font-size: 16px;
        }

        .no-selection {
            text-align: center;
            color: #6c757d;
            font-style: italic;
            margin-top: 20px;
        }

        .btn {
            padding: 8px 12px;
            border: none;
            border-radius: 5px;
            cursor: pointer;
            font-weight: 600;
            transition: all 0.2s;
            font-size: 14px;
            margin: 2px;
        }

        .btn-primary {
            background: #667eea;
            color: white;
        }

        .btn-primary:hover {
            background: #5a6fd8;
        }

        .btn-secondary {
            background: #6c757d;
            color: white;
        }

        .btn-secondary:hover {
            background: #545b62;
        }

        .btn-clear {
            background: #28a745;
            color: white;
        }

        .btn-clear:hover {
            background: #218838;
        }

        .map-container {
            flex: 1;
            position: relative;
            min-height: 400px;
        }

        #map {
            width: 100%;
            height: 100%;
            min-height: 400px;
        }

        .status {
            background: white;
            padding: 8px 20px;
            text-align: center;
            font-weight: 600;
            border-top: 1px solid #e1e5e9;
            font-size: 14px;
            flex-shrink: 0;
        }

        .status.loading {
            background: #fff3cd;
            color: #856404;
        }

        .status.success {
            background: #d4edda;
            color: #155724;
        }

        .status.error {
            background: #f8d7da;
            color: #721c24;
        }

        .dog-info {
            font-size: 12px;
            color: #666;
            margin: 5px 0;
        }
    </style>
</head>
<body>
    <div class="controls">
        <div class="control-group">
            <label for="colorBy">Color by:</label>
            <select id="colorBy">
                <option value="Combined">Combined (Driver:Group)</option>
                <option value="District">District</option>
            </select>
        </div>
        
        <div class="control-group">
            <label for="searchInput">Search:</label>
            <input type="text" id="searchInput" placeholder="Search dogs, combined names, addresses..." />
        </div>

        <div class="control-group">
            <button class="btn btn-secondary" onclick="refreshData()">üîÑ Refresh</button>
            <button class="btn btn-secondary" onclick="showStats()">üìä Stats</button>
            <button class="btn btn-secondary" onclick="resetColors()">üé® Reset Colors</button>
        </div>
    </div>

    <div class="main-content">
        <div class="left-panel">
            <div class="legend-section">
                <div style="text-align: center; margin-bottom: 6px;">
                    <button class="btn btn-clear" onclick="clearFilter()" style="width: 100%; padding: 6px 8px; font-size: 12px;">Show All</button>
                </div>
                
                <div id="legendContent">Loading...</div>
            </div>
            
            <div class="edit-section">
                <div id="detailsContent" class="no-selection">
                    Click a marker on the map to see details
                </div>
            </div>
        </div>

        <div class="map-container">
            <div id="map"></div>
        </div>
    </div>

    <div class="status" id="status">Loading dog walking data...</div>

    <!-- Leaflet JS -->
    <script src="https://unpkg.com/leaflet@1.9.4/dist/leaflet.js"></script>
    
    <script>
        // Configuration
        const CONFIG = {
            SHEET_ID: '1mg8d5CLxSR54KhNUL8SpL5jzrGN-bghTsC9vxSK8lR0',
            WORKSHEET_NAME: 'Map',
            API_KEY: 'AIzaSyAGLteYp1k98SZo0FMClRgBX0LBsgpMxqI',
            APPS_SCRIPT_URL: 'https://script.google.com/macros/s/AKfycbwhtJNojYGhpG6gwiRjo3-g_qluGWx_0q5cQplyOnEsoBF8lqxMY2RAjmq4bhfj3P4AbQ/exec',
            DEFAULT_LAT: 42.2968,
            DEFAULT_LNG: -71.2636,
            DEFAULT_ZOOM: 11
        };

        // Master color palette - 120+ unique colors
        const ALL_COLORS = [
            '#1f77b4', '#ff7f0e', '#2ca02c', '#d62728', '#9467bd', '#8c564b', '#e377c2', '#7f7f7f',
            '#bcbd22', '#17becf', '#ff9896', '#98df8a', '#c5b0d5', '#c49c94', '#f7b6d3', '#c7c7c7',
            '#FFD700', '#FF6B6B', '#4ECDC4', '#45B7D1', '#96CEB4', '#FECA57', '#FF9FF3', '#54A0FF',
            '#5F27CD', '#00D2D3', '#FF9F43', '#10AC84', '#EE5A24', '#0097E6', '#8C7AE6', '#F79F1F',
            '#A3CB38', '#E74C3C', '#3742FA', '#2F3542', '#FF3838', '#2ECC71', '#9B59B6', '#E67E22',
            '#1ABC9C', '#34495E', '#F39C12', '#E91E63', '#00BCD4', '#607D8B', '#795548', '#009688',
            '#FF5722', '#673AB7', '#3F51B5', '#2196F3', '#03DAC6', '#6200EA', '#FF4081', '#FFAB00',
            '#00E676', '#DD2C00', '#651FFF', '#FF6D00', '#FF1744', '#00E5FF', '#BF360C', '#1B5E20',
            '#0D47A1', '#F57F17', '#4A148C', '#006064', '#D50000', '#00C853', '#304FFE', '#FFD600',
            '#AA00FF', '#00B8D4', '#FF6F00', '#388E3C', '#1976D2', '#FBC02D', '#7B1FA2', '#0097A7',
            '#FF3D00', '#689F38', '#1565C0', '#F9A825', '#8E24AA', '#00ACC1', '#7CB342', '#0277BD',
            '#26C6DA', '#E65100', '#8BC34A', '#0288D1', '#FF8F00', '#4DD0E1', '#FF8A65', '#AED581',
            '#039BE5', '#FFA726', '#5E35B1', '#4FC3F7', '#FFAB91', '#C5E1A5', '#29B6F6', '#FFB74D',
            '#512DA8', '#81C784', '#FFCDD2', '#F8BBD9', '#E1BEE7', '#D1C4E9', '#C5CAE9', '#BBDEFB',
            '#B3E5FC', '#B2EBF2', '#B2DFDB', '#C8E6C9', '#DCEDC8', '#F0F4C3', '#FFF9C4', '#FFECB3',
            '#FFE0B2', '#FFCCBC', '#D7CCC8', '#F5F5F5', '#CFD8DC', '#FF8A80', '#FF80AB', '#EA80FC'
        ];

        // Global variables
        let map, markers = [], allData = [], filteredData = [], colorMap = {};
        let selectedMarker = null, selectedRow = null, currentFilter = null;
        let driverColorMap = {}; // Simple driver name -> color mapping
        let customColors = {}; // Store custom color overrides - THIS IS THE KEY!

        function assignDriverColors() {
            // Get all unique drivers from the data, sorted alphabetically for consistency
            const allDrivers = [...new Set(allData.map(row => {
                const combined = row['Combined'] || '';
                const driverName = combined.split(':')[0].trim();
                return driverName;
            }).filter(driver => driver !== ''))].sort();
            
            console.log('Found drivers:', allDrivers);
            
            // Clear existing assignments
            driverColorMap = {};
            
            // Assign colors sequentially - no duplicates possible!
            allDrivers.forEach((driver, index) => {
                if (index < ALL_COLORS.length) {
                    driverColorMap[driver] = ALL_COLORS[index];
                } else {
                    // Fallback for more than 120 drivers (very unlikely)
                    driverColorMap[driver] = '#' + Math.floor(Math.random()*16777215).toString(16);
                }
            });
            
            console.log('Driver color assignments:', driverColorMap);
            console.log(`Assigned ${Object.keys(driverColorMap).length} unique colors to drivers`);
        }

        function getDriverColor(name) {
            if (!name || name.trim() === '') return '#999999';
            // Check for custom color first - THIS IS IMPORTANT!
            if (customColors[name.trim()]) return customColors[name.trim()];
            return driverColorMap[name.trim()] || '#999999';
        }

        function getColorForValue(value, attribute) {
            if (attribute === 'Combined') {
                const driverName = value ? value.split(':')[0] : '';
                return getDriverColor(driverName);
            }
            
            // Check for custom color first for districts - THIS TOO!
            if (customColors[value]) return customColors[value];
            
            const colors = ['#1f77b4', '#ff7f0e', '#2ca02c', '#d62728', '#9467bd', '#8c564b'];
            let hash = 0;
            if (value) {
                for (let i = 0; i < value.length; i++) {
                    hash = value.charCodeAt(i) + ((hash << 5) - hash);
                }
            }
            return colors[Math.abs(hash) % colors.length];
        }

        function createMarkerIcon(color, isSelected = false, markerType = 'circle') {
            const strokeColor = '#000000';
            const strokeWidth = isSelected ? 3 : 2;
            
            if (markerType === 'field') {
                const size = 26; // 10% smaller (was 29)
                return L.divIcon({
                    html: `<svg width="${size}" height="${size + 6}" viewBox="0 0 26 32" style="filter: drop-shadow(2px 2px 4px rgba(0,0,0,0.3));">
                        <path d="M13 0C5.8 0 0 5.8 0 13c0 7.8 13 19 13 19s13-11.2 13-19C26 5.8 20.2 0 13 0z" 
                              fill="${color}" stroke="${strokeColor}" stroke-width="${strokeWidth}"/>
                        <text x="13" y="16" text-anchor="middle" fill="white" font-size="9" font-weight="bold">F</text>
                    </svg>`,
                    className: 'custom-field-marker',
                    iconSize: [size, size + 6],
                    iconAnchor: [size/2, size + 6]
                });
            } else if (markerType === 'parking') {
                const size = 23; // 10% smaller (was 25)
                return L.divIcon({
                    html: `<div style="width: ${size}px; height: ${size}px; background-color: ${color}; border: ${strokeWidth}px solid ${strokeColor}; box-shadow: 0 2px 4px rgba(0,0,0,0.3); display: flex; align-items: center; justify-content: center; color: white; font-weight: bold; font-size: 11px;">P</div>`,
                    className: 'custom-parking-marker',
                    iconSize: [size, size],
                    iconAnchor: [size/2, size/2]
                });
            } else if (markerType === 'diamond') {
                const size = 18; // 10% smaller (was 20)
                return L.divIcon({
                    html: `<div style="width: ${size}px; height: ${size}px; background-color: ${color}; border: ${strokeWidth}px solid ${strokeColor}; transform: rotate(45deg); box-shadow: 0 2px 4px rgba(0,0,0,0.3); margin: 3px;"></div>`,
                    className: 'custom-diamond-marker',
                    iconSize: [size + 6, size + 6],
                    iconAnchor: [(size + 6)/2, (size + 6)/2]
                });
            } else {
                const size = 16; // 10% smaller (was 18)
                return L.divIcon({
                    html: `<div style="width: ${size}px; height: ${size}px; background-color: ${color}; border: ${strokeWidth}px solid ${strokeColor}; border-radius: 50%; box-shadow: 0 2px 4px rgba(0,0,0,0.3);"></div>`,
                    className: 'custom-marker',
                    iconSize: [size, size],
                    iconAnchor: [size/2, size/2]
                });
            }
        }

        function initMap() {
            map = L.map('map').setView([CONFIG.DEFAULT_LAT, CONFIG.DEFAULT_LNG], CONFIG.DEFAULT_ZOOM);
            
            L.tileLayer('https://{s}.basemaps.cartocdn.com/light_all/{z}/{x}/{y}{r}.png', {
                attribution: '¬© OpenStreetMap contributors, ¬© CARTO',
                subdomains: 'abcd',
                maxZoom: 19
            }).addTo(map);

            document.getElementById('colorBy').addEventListener('change', updateMap);
            document.getElementById('searchInput').addEventListener('input', updateMap);
        }

        async function loadData() {
            updateStatus('Loading data...', 'loading');
            
            try {
                const url = `https://sheets.googleapis.com/v4/spreadsheets/${CONFIG.SHEET_ID}/values/${CONFIG.WORKSHEET_NAME}?key=${CONFIG.API_KEY}`;
                const response = await fetch(url);
                
                if (!response.ok) {
                    throw new Error(`HTTP ${response.status}: ${response.statusText}`);
                }
                
                const data = await response.json();
                
                if (!data.values || data.values.length < 2) {
                    throw new Error('No data found in the sheet');
                }
                
                const headers = data.values[0];
                const rows = data.values.slice(1);
                
                allData = rows.map(row => {
                    const obj = {};
                    headers.forEach((header, index) => {
                        obj[header] = row[index] || '';
                    });
                    return obj;
                }).filter(row => {
                    const lat = parseFloat(row['Latitude']);
                    const lng = parseFloat(row['Longitude']);
                    return !isNaN(lat) && !isNaN(lng) && row['Dog Name'] && lat !== 0 && lng !== 0;
                });

                updateStatus(`‚úÖ Loaded ${allData.length} locations`, 'success');
                
                // Assign colors to all drivers using simple sequential method
                assignDriverColors();
                
                updateMap();
                
            } catch (error) {
                updateStatus(`Error: ${error.message}`, 'error');
                console.error('Data loading error:', error);
            }
        }

        function updateMap() {
            const colorBy = document.getElementById('colorBy').value;
            const searchTerm = document.getElementById('searchInput').value.toLowerCase();

            filteredData = allData.filter(row => {
                const searchText = `${row['Dog Name']} ${row['Address']} ${row['District']} ${row['Combined']} ${row['Callout']}`.toLowerCase();
                const matchesSearch = searchText.includes(searchTerm);
                
                let matchesFilter = currentFilter === null;
                if (!matchesFilter && currentFilter !== null) {
                    if (colorBy === 'Combined') {
                        const driverName = row['Combined'] ? row['Combined'].split(':')[0] : '';
                        matchesFilter = driverName === currentFilter;
                    } else {
                        matchesFilter = row[colorBy] === currentFilter;
                    }
                }
                
                return matchesSearch && matchesFilter;
            });

            markers.forEach(m => map.removeLayer(m.marker));
            markers = [];

            if (colorBy === 'Combined') {
                const uniqueDrivers = [...new Set(allData.map(row => {
                    const combined = row['Combined'] || '';
                    return combined.split(':')[0];
                }).filter(driver => driver))];
                
                colorMap = {};
                uniqueDrivers.forEach(driver => {
                    // Use the color function that checks for custom colors
                    colorMap[driver] = getDriverColor(driver);
                });
            } else {
                const uniqueValues = [...new Set(allData.map(row => row[colorBy]))];
                colorMap = {};
                uniqueValues.forEach(value => {
                    colorMap[value] = getColorForValue(value, colorBy);
                });
            }

            filteredData.forEach((row, index) => {
                const lat = parseFloat(row['Latitude']);
                const lng = parseFloat(row['Longitude']);
                if (isNaN(lat) || isNaN(lng)) return;

                let color;
                if (colorBy === 'Combined') {
                    const driverName = row['Combined'] ? row['Combined'].split(':')[0] : '';
                    color = colorMap[driverName] || '#999999';
                } else {
                    color = colorMap[row[colorBy]] || '#999999';
                }
                
                const isSelected = selectedRow === row;
                const dogName = (row['Dog Name'] || '').toLowerCase();
                const hasCallout = row['Callout'] && row['Callout'].trim() !== '';
                
                let markerType = 'circle';
                if (dogName.includes('field')) {
                    markerType = 'field';
                } else if (dogName.includes('parking')) {
                    markerType = 'parking';
                } else if (hasCallout) {
                    markerType = 'diamond';
                    console.log('Creating diamond marker for:', row['Dog Name'], 'callout:', row['Callout']);
                }
                
                const marker = L.marker([lat, lng], {
                    icon: createMarkerIcon(color, isSelected, markerType)
                }).addTo(map);

                const popupContent = `
                    <strong>üêï ${row['Dog Name']}</strong><br>
                    <strong>üè∑Ô∏è ${row['Combined']}</strong><br>
                    ${row['Address']}<br>
                    ${row['District'] && row['District'].trim() !== '' ? `${row['District']}<br>` : ''}
                    ${row['Capacity'] && row['Capacity'].trim() !== '' ? `${row['Capacity']}<br>` : ''}
                    ${hasCallout ? `<strong>üìù CALLOUT:</strong> <span style="background: yellow; padding: 2px;">${row['Callout']}</span><br>` : ''}
                `;

                marker.bindPopup(popupContent);
                marker.on('click', () => selectMarker(marker, row, index, markerType));

                markers.push({marker, row, index, markerType});
            });

            updateLegend();
            updateStatus(`Showing ${filteredData.length} of ${allData.length} locations`, 'success');
        }

        function updateLegend() {
            const colorBy = document.getElementById('colorBy').value;
            let html = '';
            
            if (colorBy === 'Combined') {
                Object.entries(colorMap).sort(([a], [b]) => a.localeCompare(b)).forEach(([driverName, color]) => {
                    const isActive = currentFilter === driverName;
                    const driverCount = allData.filter(row => {
                        const combined = row['Combined'] || '';
                        return combined.split(':')[0] === driverName;
                    }).length;
                    
                    html += `<div class="legend-item ${isActive ? 'active' : ''}" onclick="filterByCategory('${driverName}')">
                        <div class="legend-color" style="background-color: ${color}"></div>
                        <span class="legend-text">${driverName} (${driverCount} dogs)</span>
                        <input type="color" class="color-picker" value="${color}" 
                               onclick="event.stopPropagation()" 
                               onchange="changeCustomColor('${driverName}', this.value)">
                    </div>`;
                });
            } else {
                Object.entries(colorMap).sort(([a], [b]) => a.localeCompare(b)).forEach(([category, color]) => {
                    const isActive = currentFilter === category;
                    html += `<div class="legend-item ${isActive ? 'active' : ''}" onclick="filterByCategory('${category}')">
                        <div class="legend-color" style="background-color: ${color}"></div>
                        <span class="legend-text">${category}</span>
                        <input type="color" class="color-picker" value="${color}" 
                               onclick="event.stopPropagation()" 
                               onchange="changeCustomColor('${category}', this.value)">
                    </div>`;
                });
            }
            
            document.getElementById('legendContent').innerHTML = html;
        }

        // THE MAGIC FUNCTIONS - these handle the color picking!
        function changeCustomColor(categoryName, newColor) {
            console.log('Changing color for:', categoryName, 'to:', newColor);
            customColors[categoryName] = newColor;
            updateMap(); // This will refresh the map with new colors
        }

        function resetColors() {
            console.log('Resetting all custom colors');
            customColors = {};
            updateMap(); // This will refresh back to default colors
        }

        function selectMarker(marker, row, index, markerType) {
            if (selectedMarker) {
                const prevData = markers.find(m => m.marker === selectedMarker);
                if (prevData) {
                    const colorBy = document.getElementById('colorBy').value;
                    let color;
                    if (colorBy === 'Combined') {
                        const driverName = prevData.row['Combined'] ? prevData.row['Combined'].split(':')[0] : '';
                        color = colorMap[driverName] || '#999999';
                    } else {
                        color = colorMap[prevData.row[colorBy]] || '#999999';
                    }
                    selectedMarker.setIcon(createMarkerIcon(color, false, prevData.markerType));
                }
            }

            selectedMarker = marker;
            selectedRow = row;
            
            const colorBy = document.getElementById('colorBy').value;
            let color;
            if (colorBy === 'Combined') {
                const driverName = row['Combined'] ? row['Combined'].split(':')[0] : '';
                color = colorMap[driverName] || '#999999';
            } else {
                color = colorMap[row[colorBy]] || '#999999';
            }
            marker.setIcon(createMarkerIcon(color, true, markerType));

            const actualIndex = allData.findIndex(r => r === row);
            const detailsHtml = `
                <div style="font-weight: bold; color: #333; margin-bottom: 8px; font-size: 14px;">
                    ${row['Dog Name']}
                </div>
                
                <div style="margin-bottom: 8px;">
                    <input type="text" id="editCombined" value="${row['Combined'] || ''}" 
                           style="width: 100%; padding: 6px; border: 1px solid #ddd; border-radius: 4px; font-size: 13px;">
                </div>
                
                <div style="display: flex; gap: 4px;">
                    <button class="btn btn-primary" onclick="saveCombinedName(${actualIndex})" style="flex: 1; padding: 6px 8px; font-size: 12px;">Save</button>
                    <button class="btn btn-secondary" onclick="cancelEdit()" style="flex: 1; padding: 6px 8px; font-size: 12px;">Cancel</button>
                </div>
            `;
            
            document.getElementById('detailsContent').innerHTML = detailsHtml;
        }

        function filterByCategory(category) {
            currentFilter = currentFilter === category ? null : category;
            updateMap();
        }

        function clearFilter() {
            currentFilter = null;
            document.getElementById('searchInput').value = '';
            updateMap();
        }

        function showStats() {
            if (allData.length === 0) return;
            
            const drivers = allData.reduce((acc, row) => {
                const combined = row['Combined'] || '';
                const driverName = combined.split(':')[0];
                if (driverName && driverName.trim() !== '') {
                    acc[driverName] = (acc[driverName] || 0) + 1;
                }
                return acc;
            }, {});
            
            const districts = allData.reduce((acc, row) => {
                if (row['District'] && row['District'].trim() !== '') {
                    acc[row['District']] = (acc[row['District']] || 0) + 1;
                }
                return acc;
            }, {});
            
            let statsText = "üìä DETAILED STATISTICS\n\n";
            statsText += "üë§ DRIVERS:\n";
            Object.entries(drivers).sort((a, b) => b[1] - a[1]).forEach(([name, count]) => {
                statsText += `  ${name}: ${count} dogs\n`;
            });
            
            statsText += "\nüó∫Ô∏è DISTRICTS:\n";
            Object.entries(districts).sort((a, b) => b[1] - a[1]).forEach(([district, count]) => {
                statsText += `  ${district}: ${count} dogs\n`;
            });
            
            alert(statsText);
        }

        async function saveCombinedName(index) {
            const newCombined = document.getElementById('editCombined').value.trim();
            
            if (!selectedRow || typeof index !== 'number' || !allData[index]) {
                updateStatus('‚ùå Error: Invalid selection', 'error');
                return;
            }

            // Find the actual index in allData to ensure we're updating the right row
            const actualIndex = allData.findIndex(row => row === selectedRow);
            if (actualIndex === -1) {
                updateStatus('‚ùå Error: Could not find row in data', 'error');
                return;
            }

            // Update local data immediately
            selectedRow['Combined'] = newCombined;
            allData[actualIndex]['Combined'] = newCombined;
            
            // Try to save to Google Sheets if configured
            if (CONFIG.APPS_SCRIPT_URL && CONFIG.APPS_SCRIPT_URL.trim() !== '' && !CONFIG.APPS_SCRIPT_URL.includes('YOUR_APPS_SCRIPT_URL_HERE')) {
                try {
                    updateStatus('üíæ Saving to Google Sheets...', 'loading');
                    
                    const payload = {
                        action: 'updateCombined',
                        rowIndex: actualIndex + 2, // +2 because: +1 for header row, +1 for 1-based indexing
                        dogId: selectedRow['Dog ID'] || '',
                        newCombined: newCombined
                    };
                    
                    console.log('üîß DEBUG: Sending to Apps Script:', payload);
                    console.log('üîß DEBUG: URL:', CONFIG.APPS_SCRIPT_URL);
                    
                    const response = await fetch(CONFIG.APPS_SCRIPT_URL, {
                        method: 'POST',
                        headers: { 
                            'Content-Type': 'application/json',
                        },
                        body: JSON.stringify(payload),
                        mode: 'cors' // Try CORS first
                    });

                    console.log('üîß DEBUG: Response status:', response.status);
                    console.log('üîß DEBUG: Response ok:', response.ok);

                    if (response.ok) {
                        const result = await response.json();
                        console.log('üîß DEBUG: Response data:', result);
                        if (result.success) {
                            updateStatus(`‚úÖ Saved to Google Sheets: ${newCombined}`, 'success');
                        } else {
                            throw new Error(result.error || 'Unknown error from Apps Script');
                        }
                    } else {
                        const errorText = await response.text();
                        console.log('üîß DEBUG: Error response text:', errorText);
                        throw new Error(`HTTP ${response.status}: ${response.statusText}`);
                    }
                    
                } catch (error) {
                    console.error('üîß DEBUG: Google Sheets save error:', error);
                    
                    // Try with no-cors as fallback (won't get response but might work)
                    try {
                        console.log('üîß DEBUG: Trying no-cors fallback...');
                        await fetch(CONFIG.APPS_SCRIPT_URL, {
                            method: 'POST',
                            mode: 'no-cors',
                            headers: { 'Content-Type': 'application/json' },
                            body: JSON.stringify({
                                action: 'updateCombined',
                                rowIndex: actualIndex + 2,
                                dogId: selectedRow['Dog ID'] || '',
                                newCombined: newCombined
                            })
                        });
                        updateStatus(`‚úÖ Saved to Google Sheets (no-cors): ${newCombined}`, 'success');
                    } catch (noCorsError) {
                        console.error('üîß DEBUG: No-cors also failed:', noCorsError);
                        updateStatus(`‚ö†Ô∏è Saved locally only. Sheets error: ${error.message}`, 'error');
                    }
                }
            } else {
                if (CONFIG.APPS_SCRIPT_URL.includes('YOUR_APPS_SCRIPT_URL_HERE')) {
                    updateStatus(`‚ö†Ô∏è Updated locally only. Please configure APPS_SCRIPT_URL`, 'error');
                } else {
                    updateStatus(`‚úÖ Updated locally: ${newCombined}`, 'success');
                }
            }
            
            // Re-assign colors in case driver changed
            assignDriverColors();
            updateMap();
            
            // Refresh the details panel
            if (selectedMarker) {
                const markerData = markers.find(m => m.marker === selectedMarker);
                if (markerData) {
                    selectMarker(selectedMarker, selectedRow, actualIndex, markerData.markerType);
                }
            }
        }

        function cancelEdit() {
            if (selectedMarker && selectedRow) {
                const markerData = markers.find(m => m.marker === selectedMarker);
                if (markerData) {
                    const index = allData.findIndex(row => row === selectedRow);
                    selectMarker(selectedMarker, selectedRow, index, markerData.markerType);
                }
            }
        }

        function refreshData() {
            selectedMarker = null;
            selectedRow = null;
            currentFilter = null;
            // Keep existing driver color assignments for consistency
            document.getElementById('detailsContent').innerHTML = '<div class="no-selection">Click a marker on the map to see details</div>';
            loadData();
        }

        function updateStatus(message, type = '') {
            const status = document.getElementById('status');
            status.textContent = message;
            status.className = `status ${type}`;
        }

        document.addEventListener('DOMContentLoaded', function() {
            initMap();
            loadData();
        });
    </script>
</body>
</html>
